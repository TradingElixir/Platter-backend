{
  "openapi": "3.1.0",
  "info": {
    "title": "üõ†Ô∏è Alchemy SDK",
    "version": "1.0"
  },
  "servers": [
    {
      "url": "https://alchemy-sdk-core-example.com"
    }
  ],
  "paths": {
    "/{apiKey}/call": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-call",
        "summary": "call",
        "description": "Executes a new message call immediately without creating a transaction on the block chain.",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "description": "Accepts the transaction call object.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                          "oneOf": [
                            {
                              "allOf": [
                                {
                                  "type": "object",
                                  "description": "The transaction call object",
                                  "properties": {
                                    "from": {
                                      "type": "string",
                                      "description": "20 Bytes - The address the transaction is sent from."
                                    },
                                    "to": {
                                      "type": "string",
                                      "description": "20 Bytes - The address the transaction is directed to"
                                    },
                                    "gasPrice": {
                                      "type": "string",
                                      "description": "Integer of the gasPrice used for each paid gas.\n<br/><strong>NOTE:</strong> most of our users <b>(95%+)</b> never set the gasPrice on eth_call.\n"
                                    },
                                    "value": {
                                      "type": "string",
                                      "description": "Integer of the value sent with this transaction"
                                    },
                                    "data": {
                                      "type": "string",
                                      "description": "Hash of the method signature and encoded parameters"
                                    }
                                  },
                                  "required": [
                                    "to"
                                  ]
                                },
                                {
                                  "type": "object",
                                  "properties": {
                                    "gas": {
                                      "type": "string",
                                      "description": "Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions. \n</br><strong> NOTE: </strong>this parameter has a cap of <b>550</b> Million gas per request. Reach out to us at support@alchemy.com if you want to increase this limit!\n"
                                    }
                                  }
                                }
                              ]
                            },
                            {
                              "type": "string",
                              "description": "String - Either the hex value of a **block number** OR One of the following **block tags**: \n  * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n  * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n  * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n  * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n  * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n"
                            }
                          ]
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\n// Make a sample eth_call\nalchemy.core\n  .call({\n    to: \"0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41\",\n    gas: \"0x76c0\",\n    gasPrice: \"0x9184e72a000\",\n    data: \"0x3b3b57debf074faa138b72c65adbdcfb329847e4f2c04bde7f7dd7fcad5a52d2f395a558\",\n  })\n  .then(console.log);\n"
            },
            {
              "language": "python",
              "code": "from web3 import Web3, HTTPProvider\r\n\r\n#Replace with your Alchemy API key:\r\napiKey = \"demo\"\r\n\r\n# Initialize a Web3.py instance\r\nweb3 = Web3(Web3.HTTPProvider('https://eth-mainnet.alchemyapi.io/v2/'+apiKey))\r\n\r\n# Query the blockchain (replace example parameters)\r\ndata = web3.eth.call({\r\n\t\t'value': 0, \r\n\t\t'gas': 21736, \r\n\t\t'maxFeePerGas': 2000000000, \r\n\t\t'maxPriorityFeePerGas': 1000000000, \r\n\t\t'to': '0xc305c90',\r\n\t\t'data': '0x477a5c98'\r\n\t\t}) \r\n\r\n# Print the output to console\r\nprint(data)",
              "name": "web3.py"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns integer of the number of transactions in this block.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                },
                "examples": {
                  "default": {
                    "summary": "Sample Response",
                    "value": "0x0000000000000000000000005555763613a12d8f3e73be831dff8598089d3dca"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/estimateGas": {
      "post": {
        "operationId": "sdk-estimateGas",
        "summary": "estimateGas",
        "description": "Generates and returns an estimate of how much gas is necessary to allow the transaction to complete. The transaction will not be added to the blockchain.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                          "oneOf": [
                            {
                              "allOf": [
                                {
                                  "type": "object",
                                  "description": "The transaction call object",
                                  "properties": {
                                    "from": {
                                      "type": "string",
                                      "description": "20 Bytes - The address the transaction is sent from."
                                    },
                                    "to": {
                                      "type": "string",
                                      "description": "20 Bytes - The address the transaction is directed to"
                                    },
                                    "gasPrice": {
                                      "type": "string",
                                      "description": "Integer of the gasPrice used for each paid gas.\n<br/><strong>NOTE:</strong> most of our users <b>(95%+)</b> never set the gasPrice on eth_call.\n"
                                    },
                                    "value": {
                                      "type": "string",
                                      "description": "Integer of the value sent with this transaction"
                                    },
                                    "data": {
                                      "type": "string",
                                      "description": "Hash of the method signature and encoded parameters"
                                    }
                                  },
                                  "required": [
                                    "to"
                                  ]
                                },
                                {
                                  "type": "object",
                                  "properties": {
                                    "gas": {
                                      "type": "string",
                                      "description": "Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions. \n</br><strong> NOTE: </strong>this parameter has a cap of <b>550</b> Million gas per request. Reach out to us at support@alchemy.com if you want to increase this limit!\n"
                                    }
                                  }
                                }
                              ]
                            },
                            {
                              "type": "string",
                              "description": "String - Either the hex value of a **block number** OR One of the following **block tags**: \n  * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n  * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n  * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n  * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n  * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n"
                            }
                          ]
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy, Utils } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .estimateGas({\n    // Wrapped ETH address\n    to: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n    // `function deposit() payable`\n    data: \"0xd0e30db0\",\n    // 1 ether\n    value: Utils.parseEther(\"1.0\"),\n  })\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns the amount of gas used.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/findContractDeployer": {
      "post": {
        "operationId": "sdk-findContractDeployer",
        "summary": "findContractDeployer",
        "description": "Finds the address that deployed the provided contract and block number it was deployed in.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "contractAddress": {
                        "type": "string",
                        "description": "The contract address to find the deployer for."
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .findContractDeployer(\"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns the address of the contract deployer and the block number where it was deployed.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "deployerAddress": {
                          "type": "string",
                          "description": "The address of the contract deployer, if it is available."
                        },
                        "blockNumber": {
                          "type": "number",
                          "description": "The block number the contract was deployed in."
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getAssetTransfers": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-getAssetTransfers",
        "summary": "getAssetTransfers",
        "description": "The Transfers API allows you to easily fetch historical transactions for any address across Ethereum and supported L2s including Polygon, Arbitrum, and Optimism.",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "object",
                          "required": [
                            "category"
                          ],
                          "properties": {
                            "fromBlock": {
                              "type": "string",
                              "description": "String - Inclusive from block (hex string, int, or latest)",
                              "default": "0x0"
                            },
                            "toBlock": {
                              "type": "string",
                              "description": "String - Inclusive to block (hex string, int, or latest)",
                              "default": "latest"
                            },
                            "fromAddress": {
                              "type": "string",
                              "description": "String - From address (hex string). Default wildcard - any address"
                            },
                            "toAddress": {
                              "type": "string",
                              "description": "String - To address (hex string). Default wildcard - any address"
                            },
                            "contractAddresses": {
                              "type": "array",
                              "description": "String - List of contract addresses (hex strings) to filter for - only applies to \"erc20\", \"erc721\", \"erc1155\" transfers. Default wildcard - any address",
                              "items": {
                                "type": "string"
                              }
                            },
                            "category": {
                              "type": "array",
                              "description": "'Array of categories, can be any of the following: \"external\", \"internal\", \"erc20\", \"erc721\", \"erc1155\", or \"specialnft\". See the table above for supported categories on each network.'\n",
                              "items": {
                                "type": "string",
                                "enum": [
                                  "external",
                                  "internal",
                                  "erc20",
                                  "erc721",
                                  "erc1155",
                                  "specialnft"
                                ]
                              }
                            },
                            "order": {
                              "type": "string",
                              "description": "String - Whether to return results in ascending (`asc`) or descending (`desc`) order. Ascending order is from oldest to newest transactions, decending order is from newest to oldest. Defaults to \"asc\" if omitted.\n",
                              "enum": [
                                "asc",
                                "desc"
                              ]
                            },
                            "withMetadata": {
                              "type": "boolean",
                              "description": "Boolean - Whether or not to include additional metadata about each transfer event.",
                              "default": false
                            },
                            "excludeZeroValue": {
                              "type": "boolean",
                              "description": "Boolean - A boolean to exclude transfers with zero value. Zero value is not the same as null value.",
                              "default": true
                            },
                            "maxCount": {
                              "type": "string",
                              "description": "Max hex string number of results to return per call.",
                              "default": "0x3e8"
                            },
                            "pageKey": {
                              "type": "string",
                              "description": "String - UUID for pagination. If more results are available, a uuid pageKey will be returned in the response. Pass that uuid into pageKey to fetch the next 1000 or maxCount."
                            }
                          }
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\nimport { Alchemy, Network } from \"alchemy-sdk\";\n\nconst config = {\n  apiKey: \"demo\",\n  network: Network.ETH_MAINNET,\n};\nconst alchemy = new Alchemy(config);\n\n// Address we want get NFT mints from\nconst toAddress = \"0x1E6E8695FAb3Eb382534915eA8d7Cc1D1994B152\";\n\nconst res = await alchemy.core.getAssetTransfers({\n  fromBlock: \"0x0\",\n  fromAddress: \"0x0000000000000000000000000000000000000000\",\n  toAddress: toAddress,\n  excludeZeroValue: true,\n  category: [\"erc721\", \"erc1155\"],\n});\n\nconsole.log(res);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "object",
                          "description": "An object with the following fields.",
                          "properties": {
                            "pageKey": {
                              "type": "string",
                              "description": "Uuid of next page of results (if exists, else blank)."
                            },
                            "transfers": {
                              "type": "array",
                              "description": "Array of objects - sorted in ascending order by block number, ties broken by category (external , internal, token transfers).",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "category": {
                                    "type": "string",
                                    "description": "'external', 'internal', 'token', 'erc20', 'erc721', 'erc1155', 'specialnft' - label for the transfer."
                                  },
                                  "token": {
                                    "type": "string",
                                    "description": "'includes 'erc20' and 'erc721' transfers."
                                  },
                                  "blockNum": {
                                    "type": "string",
                                    "description": "The block where the transfer occurred (hex string)."
                                  },
                                  "from": {
                                    "type": "string",
                                    "description": "From address of transfer (hex string)."
                                  },
                                  "to": {
                                    "type": "string",
                                    "description": "To address of transfer (hex string). null if contract creation."
                                  },
                                  "value": {
                                    "type": "string",
                                    "nullable": true,
                                    "description": "Converted asset transfer value as a number (raw value divided by contract decimal). null if ERC721 transfer or contract decimal not available."
                                  },
                                  "erc721TokenId": {
                                    "type": "string",
                                    "nullable": true,
                                    "description": "Raw ERC721 token id (hex string). null if not an ERC721 token transfer."
                                  },
                                  "erc1155Metadata": {
                                    "type": "string",
                                    "nullable": true,
                                    "description": "A list of objects containing the ERC1155 tokenId (hex string) and value (hex string). null if not an ERC1155 transfer."
                                  },
                                  "tokenId": {
                                    "type": "string",
                                    "description": "Token ID for ERC721 (or other NFT) tokens."
                                  },
                                  "asset": {
                                    "type": "string",
                                    "nullable": true,
                                    "description": "ETH or the token's symbol. null if not defined in the contract and not available from other sources."
                                  },
                                  "uniqueId": {
                                    "type": "string",
                                    "description": "A unique identifier for the transfer object."
                                  },
                                  "hash": {
                                    "type": "string",
                                    "description": "Transaction hash (hex string)."
                                  },
                                  "rawContract": {
                                    "type": "object",
                                    "properties": {
                                      "value": {
                                        "type": "string",
                                        "nullable": true,
                                        "description": "Raw transfer value (hex string). null if ERC721 or ERC1155 transfer."
                                      },
                                      "address": {
                                        "type": "string",
                                        "nullable": true,
                                        "description": "Contract address (hex string). null if external or internal transfer."
                                      },
                                      "decimal": {
                                        "type": "string",
                                        "nullable": true,
                                        "description": "Contract decimal (hex string). null if not defined in the contract and not available from other sources."
                                      }
                                    }
                                  },
                                  "metadata": {
                                    "type": "object",
                                    "properties": {
                                      "blockTimestamp": {
                                        "type": "string",
                                        "description": "Timestamp of the block from which the transaction event originated (ISO-formatted timestamp)."
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getBalance": {
      "post": {
        "operationId": "sdk-getBalance",
        "summary": "getBalance",
        "description": "Returns the balance of the account of a given address.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "1. String - 20 Bytes - Address\n2. String - Either the hex value of a **block number** OR One of the following **block tags**: \n    * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n    * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n    * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n    * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n    * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getBalance(\"vitalik.eth\", \"latest\").then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns hex value of the current ETH balance for the given address, measured in wei.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getBlock": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-getBlock",
        "summary": "getBlock",
        "description": "Returns the block from the network based on the provided block number or hash.",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "One of the following:\n1. String - Hash associated with the block\n2. Number - Number associated with the block\n"
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .getBlock(\n    \"0x92fc42b9642023f2ee2e88094df80ce87e15d91afa812fef383e6e5cd96e2ed3\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns a block object with the following fields, or null when no block was found.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "allOf": [
                            {
                              "type": "object",
                              "properties": {
                                "nonce": {
                                  "type": "string",
                                  "description": "8 Bytes - hash of the generated proof-of-work. null when its pending block."
                                },
                                "hash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the block. null when its pending block."
                                }
                              }
                            },
                            {
                              "type": "object",
                              "description": "A block object with the following fields, or null when no block was found.",
                              "properties": {
                                "number": {
                                  "type": "string",
                                  "description": "the block number. null when its pending block."
                                },
                                "parentHash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the parent block."
                                },
                                "sha3Uncles": {
                                  "type": "string",
                                  "description": "32 Bytes - SHA3 of the uncles data in the block."
                                },
                                "logsBloom": {
                                  "type": "string",
                                  "description": "256 Bytes - the bloom filter for the logs of the block. null when its pending block."
                                },
                                "transactionsRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the transaction trie of the block."
                                },
                                "stateRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the final state trie of the block."
                                },
                                "receiptsRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the receipts trie of the block."
                                },
                                "miner": {
                                  "type": "string",
                                  "description": "20 Bytes - the address of the beneficiary to whom the mining rewards were given."
                                },
                                "difficulty": {
                                  "type": "string",
                                  "description": "integer of the difficulty for this block."
                                },
                                "totalDifficulty": {
                                  "type": "string",
                                  "description": "integer of the total difficulty of the chain until this block."
                                },
                                "extraData": {
                                  "type": "string",
                                  "description": "the \"extra data\" field of this block."
                                },
                                "size": {
                                  "type": "string",
                                  "description": "integer the size of this block in bytes."
                                },
                                "gasLimit": {
                                  "type": "string",
                                  "description": "the maximum gas allowed in this block."
                                },
                                "gasUsed": {
                                  "type": "string",
                                  "description": "the total used gas by all transactions in this block."
                                },
                                "timestamp": {
                                  "type": "string",
                                  "description": "the unix timestamp for when the block was collated."
                                },
                                "transactions": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "description": "Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter."
                                },
                                "uncles": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "description": "Array of uncle hashes."
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                },
                "examples": {
                  "default": {
                    "summary": "Sample Response",
                    "value": "{\n  hash: '0x92fc42b9642023f2ee2e88094df80ce87e15d91afa812fef383e6e5cd96e2ed3',\n  parentHash: '0x6890edf8ad6900a5472c2a7ee3ef795f020ef6f907afb7f4ebf6a92d6aeb1804',\n  number: 15221026,\n  timestamp: 1658877717,\n  nonce: '0xd8c399035d6e6e8f',\n  difficulty: null,\n  gasLimit: BigNumber { _hex: '0x01ca35d2', _isBigNumber: true },\n  gasUsed: BigNumber { _hex: '0x01ca1ae1', _isBigNumber: true },\n  miner: '0x52bc44d5378309EE2abF1539BF71dE1b7d7bE3b5',\n  extraData: '0x6e616e6f706f6f6c2e6f7267',\n  transactions: [\n    '0xba4938ea41154427c8cb424ea89d9f150f139ed10065fe43ce11102dc82e1c37',\n    '0x98cc6b4b66453e184f65728fee265a726b030c5ddcfc1311a01ea5345c3959ab',\n    '0x2cbb4968cce66c73f2755fe7ef177981962afa7943f658b323e61850f31e4163'\n  ],\n  baseFeePerGas: BigNumber { _hex: '0x02aa2d1d80', _isBigNumber: true },\n  _difficulty: BigNumber { _hex: '0x2a31d8a2cf4dd7', _isBigNumber: true }\n}\n"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getBlockNumber": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-getblocknumber",
        "summary": "getBlockNumber",
        "description": "Returns the number of the most recent block.",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\n// Get the latest block number\nalchemy.core.getBlockNumber().then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns integer of the current block number the client is on.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "description": "Integer of the current block number the client is on.",
                      "properties": {
                        "result": {
                          "type": "number",
                          "description": "Integer of the current block number the client is on."
                        }
                      }
                    }
                  ]
                },
                "examples": {
                  "default": {
                    "summary": "Sample Response",
                    "value": "15534524"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getBlockWithTransactions": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-getBlockWithTransactions",
        "summary": "getBlockWithTransactions",
        "description": "Returns the block from the network based on the provided block number or hash. Includes fully transactions from the block.",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "One of the following:\n1. String - Hash associated with the block\n2. Number - Number associated with the block\n"
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .getBlockWithTransactions(\n    \"0x92fc42b9642023f2ee2e88094df80ce87e15d91afa812fef383e6e5cd96e2ed3\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns a block object with the following fields, or null when no block was found.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "allOf": [
                            {
                              "type": "object",
                              "properties": {
                                "nonce": {
                                  "type": "string",
                                  "description": "8 Bytes - hash of the generated proof-of-work. null when its pending block."
                                },
                                "hash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the block. null when its pending block."
                                }
                              }
                            },
                            {
                              "type": "object",
                              "description": "A block object with the following fields, or null when no block was found.",
                              "properties": {
                                "number": {
                                  "type": "string",
                                  "description": "the block number. null when its pending block."
                                },
                                "parentHash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the parent block."
                                },
                                "sha3Uncles": {
                                  "type": "string",
                                  "description": "32 Bytes - SHA3 of the uncles data in the block."
                                },
                                "logsBloom": {
                                  "type": "string",
                                  "description": "256 Bytes - the bloom filter for the logs of the block. null when its pending block."
                                },
                                "transactionsRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the transaction trie of the block."
                                },
                                "stateRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the final state trie of the block."
                                },
                                "receiptsRoot": {
                                  "type": "string",
                                  "description": "32 Bytes - the root of the receipts trie of the block."
                                },
                                "miner": {
                                  "type": "string",
                                  "description": "20 Bytes - the address of the beneficiary to whom the mining rewards were given."
                                },
                                "difficulty": {
                                  "type": "string",
                                  "description": "integer of the difficulty for this block."
                                },
                                "totalDifficulty": {
                                  "type": "string",
                                  "description": "integer of the total difficulty of the chain until this block."
                                },
                                "extraData": {
                                  "type": "string",
                                  "description": "the \"extra data\" field of this block."
                                },
                                "size": {
                                  "type": "string",
                                  "description": "integer the size of this block in bytes."
                                },
                                "gasLimit": {
                                  "type": "string",
                                  "description": "the maximum gas allowed in this block."
                                },
                                "gasUsed": {
                                  "type": "string",
                                  "description": "the total used gas by all transactions in this block."
                                },
                                "timestamp": {
                                  "type": "string",
                                  "description": "the unix timestamp for when the block was collated."
                                },
                                "transactions": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "description": "Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter."
                                },
                                "uncles": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "description": "Array of uncle hashes."
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                },
                "examples": {
                  "default": {
                    "summary": "Sample Response",
                    "value": "{\n  hash: '0x92fc42b9642023f2ee2e88094df80ce87e15d91afa812fef383e6e5cd96e2ed3',\n  parentHash: '0x6890edf8ad6900a5472c2a7ee3ef795f020ef6f907afb7f4ebf6a92d6aeb1804',\n  number: 15221026,\n  timestamp: 1658877717,\n  nonce: '0xd8c399035d6e6e8f',\n  difficulty: null,\n  gasLimit: BigNumber { _hex: '0x01ca35d2', _isBigNumber: true },\n  gasUsed: BigNumber { _hex: '0x01ca1ae1', _isBigNumber: true },\n  miner: '0x52bc44d5378309EE2abF1539BF71dE1b7d7bE3b5',\n  extraData: '0x6e616e6f706f6f6c2e6f7267',\n  transactions: [\n    {\n      hash: '0x58bbdd890cc828a70cf6d65f103d7723e945197b53da2c263ea6270a82fb2ccb',\n      type: 2,\n      accessList: [],\n      blockHash: '0x92fc42b9642023f2ee2e88094df80ce87e15d91afa812fef383e6e5cd96e2ed3',\n      blockNumber: 15221026,\n      transactionIndex: 57,\n      confirmations: 329310,\n      from: '0x7abE0cE388281d2aCF297Cb089caef3819b13448',\n      gasPrice: [BigNumber],\n      maxPriorityFeePerGas: [BigNumber],\n      maxFeePerGas: [BigNumber],\n      gasLimit: [BigNumber],\n      to: '0x7BA11217CCd0eD428924295BF7f13D50E75B68A4',\n      value: [BigNumber],\n      nonce: 310301,\n      data: '0x',\n      r: '0x79a3a0a0a9707c3c679e702b115562ce1bc5c8c761891baf05dfae2ddcc38599',\n      s: '0x488153c1dcdb9b03af4199070b67476fa8f24af865e0f448fb7f538b004b0991',\n      v: 1,\n      creates: null,\n      chainId: 1,\n      wait: [Function (anonymous)]\n    }\n  ],\n  baseFeePerGas: BigNumber { _hex: '0x02aa2d1d80', _isBigNumber: true },\n  _difficulty: BigNumber { _hex: '0x2a31d8a2cf4dd7', _isBigNumber: true }\n}\n"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getCode": {
      "post": {
        "operationId": "sdk-getCode",
        "summary": "getCode",
        "description": "Returns code at a given address.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "1. String - 20 Bytes - Address\n2. String - Either the hex value of a **block number** OR One of the following **block tags**: \n    * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n    * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n    * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n    * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n    * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getCode(\"registrar.firefly.eth\").then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns the code from the given address.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/feeData": {
      "post": {
        "operationId": "sdk-feeData",
        "summary": "feeData",
        "description": "Returns the recommended fee data to use in a transaction. For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas should be used. For legacy transactions and networks which do not support EIP-1559, the gasPrice should be used.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getFeeData().then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns integer of the current gas price in wei.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "maxFeePerGas": {
                          "type": "number",
                          "description": "BigNumber - The maxFeePerGas to use for a transaction. This is based on the most recent block's baseFee."
                        },
                        "maxPriorityFeePerGas": {
                          "type": "number",
                          "description": "BigNumber - The maxPriorityFeePerGas to use for a transaction. This accounts for the uncle risk and for the majority of current MEV risk."
                        },
                        "gasPrice": {
                          "type": "number",
                          "description": "BigNumber - The gasPrice to use for legacy transactions or networks which do not support EIP-1559."
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getGasPrice": {
      "post": {
        "operationId": "sdk-getGasPrice",
        "summary": "getGasPrice",
        "description": "Returns the current price per gas in wei.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getGasPrice().then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns integer of the current gas price in wei.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getLogs": {
      "post": {
        "tags": [
          "SDK Core Endpoints"
        ],
        "operationId": "sdk-getlogs",
        "summary": "getLogs",
        "description": "Returns an array of all logs matching a given filter object. Returns logs which are records that denote/provide context on specific events within a smart contract, like a token transfer or a change of ownership for example.\n",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "object",
                          "properties": {
                            "blockHash": {
                              "type": "string",
                              "description": "Using blockHash is equivalent to fromBlock = toBlock = the block number with hash blockHash. If blockHash is present in the filter criteria, then neither fromBlock nor toBlock are allowed."
                            },
                            "address": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "description": "Contract address or a list of addresses from which logs should originate."
                            },
                            "fromBlock": {
                              "type": "string",
                              "description": "String - Either the hex value of a **block number** OR One of the following **block tags**: \n  * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n  * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n  * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n  * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n  * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                              "default": "latest"
                            },
                            "toBlock": {
                              "type": "string",
                              "description": "String - Either the hex value of a **block number** OR One of the following **block tags**: \n  * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n  * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n  * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n  * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n  * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                              "default": "latest"
                            },
                            "topics": {
                              "type": "array",
                              "description": "Array of 32 Bytes DATA topics. Topics are order-dependent. Each topic can also be an array of DATA with \"or\" options.",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\n// Get logs for a certain address, with specified topics and blockHash\nalchemy.core\n  .getLogs({\n    address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n    topics: [\n      \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n    ],\n    blockHash:\n      \"0x49664d1de6b3915d7e6fa297ff4b3d1c5328b8ecf2ff0eefb912a4dc5f6ad4a0\",\n  })\n  .then(console.log);\n"
            },
            {
              "language": "python",
              "name": "Web3.py",
              "code": "# Installation Instructions: https://web3py.readthedocs.io/en/latest/quickstart.html#installation\n\nfrom web3 import Web3, HTTPProvider\n\n#Replace with your Alchemy API key:\napiKey = \"demo\"\n\n# Initialize a Web3.py instance\nweb3 = Web3(Web3.HTTPProvider('https://eth-mainnet.alchemyapi.io/v2/'+apiKey))\n\n# Query the blockchain (replace example parameters)\nlogs = web3.eth.get_logs({\n  'fromBlock': 1000000, \n  'toBlock': 1000100, \n  'address': '0x6C8f2A1'\n  }) \n\n# Print the output to console\nprint(logs)\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns array of log objects, or an empty array if nothing has changed since last poll.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "array",
                          "description": "Array of log objects, or an empty array if nothing has changed since last poll.",
                          "items": {
                            "allOf": [
                              {
                                "type": "object",
                                "properties": {
                                  "blockHash": {
                                    "type": "string",
                                    "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                  },
                                  "blockNumber": {
                                    "type": "string",
                                    "description": "The block number where this log was in. null when its pending. null when its pending log."
                                  },
                                  "transactionIndex": {
                                    "type": "string",
                                    "description": "Integer of the transactions index position log was created from. null when its pending log."
                                  }
                                }
                              },
                              {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "description": "20 Bytes - address from which this log originated."
                                  },
                                  "logIndex": {
                                    "type": "string",
                                    "description": "Integer of the log index position in the block. null when its pending log."
                                  },
                                  "data": {
                                    "type": "string",
                                    "description": "Contains one or more 32 Bytes non-indexed arguments of the log."
                                  },
                                  "removed": {
                                    "type": "boolean",
                                    "description": "true when the log was removed, due to a chain reorganization. false if its a valid log."
                                  },
                                  "topics": {
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "description": "Array of zero to four 32 Bytes DATA of indexed log arguments. In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declare the event with the anonymous specifier."
                                  },
                                  "transactionHash": {
                                    "type": "string",
                                    "description": "Hash of the transactions this log was created from. null when its pending log."
                                  }
                                }
                              }
                            ]
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getStorageAt": {
      "post": {
        "operationId": "sdk-getStorageAt",
        "summary": "getStorageAt",
        "description": "Returns the value from a storage position at a given address, or in other words, returns the state of the contract's storage, which may not be exposed via the contract's methods.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "1. String - 20 Bytes - address of the storage \n2. String - Integer of the slot position in the storage (in hex)\n3. String - Either the hex value of a **block number** OR One of the following **block tags**: \n  * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n  * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n  * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n  * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n  * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                        "minItems": 3,
                        "maxItems": 3,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getStorageAt(\"registrar.firefly.eth\", 0).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns the value at this storage position.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getTokenBalances": {
      "post": {
        "operationId": "sdk-getTokenBalances",
        "summary": "getTokenBalances",
        "description": "Returns token balances for a specific address given a list of contracts. Alchemy Enhanced API.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "- DATA, 20 Bytes - The address for which token balances will be checked.\n- OneOf\n  - Array - A list of contract addresses. Suggested limit: 100 addresses\n  - The String ''DEFAULT_TOKENS'' - denotes a query for the top 100 tokens by 24 hour volume - only available on Mainnet for Ethereum, Polygon, and Arbitrum.\n  - The String ''erc20'' - denotes the set of erc20 tokens that the address has ever held.\n",
                        "minItems": 2,
                        "maxItems": 3,
                        "items": {
                          "allOf": [
                            {
                              "type": "string"
                            },
                            {
                              "oneOf": [
                                {
                                  "type": "array",
                                  "minItems": 1,
                                  "maxItems": 100,
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                {
                                  "type": "string",
                                  "enum": [
                                    "DEFAULT_TOKENS",
                                    "erc20"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "object",
                              "properties": {
                                "pageKey": {
                                  "type": "string",
                                  "description": "An address used for pagination. If more results are available, a pageKey will be returned in the response.",
                                  "default": "0x0"
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nconst vitalikAddress = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";\nconst usdcContract = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\n// Print token balances of USDC in Vitalik's address\nalchemy.core.getTokenBalances(vitalikAddress, [usdcContract]).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "object",
                          "properties": {
                            "address": {
                              "type": "string",
                              "description": "DATA, 20 Bytes - The address for which token balances were checked."
                            },
                            "tokenBalances": {
                              "type": "array",
                              "description": "Array - returns an array of token balance objects. One of tokenBalance or error will be null.",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "contractAddress": {
                                    "type": "string"
                                  },
                                  "tokenBalance": {
                                    "type": "string"
                                  },
                                  "error": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getTokenMetadata": {
      "post": {
        "operationId": "sdk-getTokenMetadata",
        "summary": "getTokenMetadata",
        "description": "Returns metadata (name, symbol, decimals, logo) for a given token contract address.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "DATA, 20 Bytes - Singluar address for the token contract.",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\n// Print token metadata of USDC\nconst usdcContract = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\nalchemy.core.getTokenMetadata(usdcContract).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "object",
                          "properties": {
                            "name": {
                              "type": "string",
                              "description": "String - The token's name. null if not defined in the contract and not available from other sources."
                            },
                            "symbol": {
                              "type": "string",
                              "description": "String - The token's symbol. null if not defined in the contract and not available from other sources."
                            },
                            "decimals": {
                              "type": "number",
                              "description": "Number - The number of decimals of the token. null if not defined in the contract and not available from other sources."
                            },
                            "logo": {
                              "type": "string",
                              "description": "String - URL of the token's logo image. null if not available."
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getTransactionCount": {
      "post": {
        "operationId": "sdk-getTransactionCount",
        "summary": "getTransactionCount",
        "description": "Returns the number of transactions sent from an address.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "1. String - 20 Bytes - Address\n2. String - Either the hex value of a **block number** OR One of the following **block tags**: \n    * `pending` - A sample next block built by the client on top of latest and containing the set of transactions usually taken from local mempool. Intuitively, you can think of these as blocks that have not been mined yet.\n    * `latest` - The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions.\n    * `safe` - The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is ‚Äúunlikely‚Äù to be re-orged. **Only available on Ethereum Goerli**.\n    * `finalized` - The most recent crypto-economically secure block, that has been accepted by >2/3 of validators. Cannot be re-orged outside of manual intervention driven by community coordination. Intuitively, this block is very unlikely to be re-orged. **Only available on Ethereum Goerli**.\n    * `earliest` - The lowest numbered block the client has available. Intuitively, you can think of this as the first block created.\n",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core.getTransactionCount(\"vitalik.eth\").then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "number"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getTransactionReceipt": {
      "post": {
        "operationId": "sdk-getTransactionReceipt",
        "summary": "getTransactionReceipt",
        "description": "Returns the receipt of a transaction by transaction hash.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "String - 32 Bytes - Hash of a transaction",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .getTransactionReceipt(\n    \"0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "description": "A transaction receipt object, or null when no receipt was found",
                          "allOf": [
                            {
                              "type": "object",
                              "properties": {
                                "blockHash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                },
                                "blockNumber": {
                                  "type": "string",
                                  "description": "The block number where this log was in. null when its pending. null when its pending log."
                                },
                                "transactionIndex": {
                                  "type": "string",
                                  "description": "Integer of the transactions index position log was created from. null when its pending log."
                                }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "transactionHash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the transaction"
                                },
                                "from": {
                                  "type": "string",
                                  "description": "20 Bytes - address of the sender"
                                },
                                "to": {
                                  "type": "string",
                                  "description": "20 Bytes - address of the receiver. null when its a contract creation transaction"
                                },
                                "cumulativeGasUsed": {
                                  "type": "string",
                                  "description": "The total amount of gas used when this transaction was executed in the block."
                                },
                                "gasUsed": {
                                  "type": "string",
                                  "description": "The amount of gas used by this specific transaction alone"
                                },
                                "contractAddress": {
                                  "type": "string",
                                  "description": "20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null"
                                },
                                "logs": {
                                  "type": "array",
                                  "description": "Array of log objects, which this transaction generated",
                                  "items": {
                                    "allOf": [
                                      {
                                        "type": "object",
                                        "properties": {
                                          "blockHash": {
                                            "type": "string",
                                            "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                          },
                                          "blockNumber": {
                                            "type": "string",
                                            "description": "The block number where this log was in. null when its pending. null when its pending log."
                                          },
                                          "transactionIndex": {
                                            "type": "string",
                                            "description": "Integer of the transactions index position log was created from. null when its pending log."
                                          }
                                        }
                                      },
                                      {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "type": "string",
                                            "description": "20 Bytes - address from which this log originated."
                                          },
                                          "logIndex": {
                                            "type": "string",
                                            "description": "Integer of the log index position in the block. null when its pending log."
                                          },
                                          "data": {
                                            "type": "string",
                                            "description": "Contains one or more 32 Bytes non-indexed arguments of the log."
                                          },
                                          "removed": {
                                            "type": "boolean",
                                            "description": "true when the log was removed, due to a chain reorganization. false if its a valid log."
                                          },
                                          "topics": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            },
                                            "description": "Array of zero to four 32 Bytes DATA of indexed log arguments. In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declare the event with the anonymous specifier."
                                          },
                                          "transactionHash": {
                                            "type": "string",
                                            "description": "Hash of the transactions this log was created from. null when its pending log."
                                          }
                                        }
                                      }
                                    ]
                                  }
                                },
                                "logsBloom": {
                                  "type": "string",
                                  "description": "256 Bytes - Bloom filter for light clients to quickly retrieve related logs"
                                },
                                "root": {
                                  "type": "string",
                                  "description": "32 bytes of post-transaction stateroot (pre Byzantium)"
                                },
                                "status": {
                                  "type": "integer",
                                  "description": "Either 1 (success) or 0 (failure)",
                                  "enum": [
                                    0,
                                    1
                                  ]
                                },
                                "effectiveGasPrice": {
                                  "type": "string"
                                },
                                "type": {
                                  "type": "string"
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getTransactionReceipts": {
      "post": {
        "summary": "getTransactionReceipts",
        "description": "An Alchemy Enhanced API that gets all transaction receipts for a given block by number or block hash. Supported on all networks for Ethereum, Polygon, and Arbitrum.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "The api only takes in one parameter - an object with at least a blockNumber or blockHash. If both are provided, blockHash is prioritized.",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "object",
                          "properties": {
                            "blockNumber": {
                              "type": "string",
                              "description": "The block number you want to get transaction receipts for, in hex",
                              "pattern": "^0[xX][0-9a-fA-F]+$"
                            },
                            "blockHash": {
                              "type": "string",
                              "description": "The block hash you want to get transaction receipts for"
                            }
                          }
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .getTransactionReceipts(\n    \"0x18760312114f3fdf11f9d5846245995835aa59994d5fc4203faee52d2f7eaabe\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "A list of transaction receipts for each transaction in this block.",
            "content": {
              "application/json": {
                "schema": {
                  "description": "A list of transaction receipts for each transaction in this block",
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "receipts": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "transactionHash": {
                                "type": "string",
                                "description": "32 Bytes - hash of the transaction"
                              },
                              "from": {
                                "type": "string",
                                "description": "20 Bytes - address of the sender"
                              },
                              "to": {
                                "type": "string",
                                "description": "20 Bytes - address of the receiver. null when its a contract creation transaction"
                              },
                              "cumulativeGasUsed": {
                                "type": "string",
                                "description": "The total amount of gas used when this transaction was executed in the block."
                              },
                              "gasUsed": {
                                "type": "string",
                                "description": "The amount of gas used by this specific transaction alone"
                              },
                              "contractAddress": {
                                "type": "string",
                                "description": "20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null"
                              },
                              "logs": {
                                "type": "array",
                                "description": "Array of log objects, which this transaction generated",
                                "items": {
                                  "allOf": [
                                    {
                                      "type": "object",
                                      "properties": {
                                        "blockHash": {
                                          "type": "string",
                                          "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                        },
                                        "blockNumber": {
                                          "type": "string",
                                          "description": "The block number where this log was in. null when its pending. null when its pending log."
                                        },
                                        "transactionIndex": {
                                          "type": "string",
                                          "description": "Integer of the transactions index position log was created from. null when its pending log."
                                        }
                                      }
                                    },
                                    {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "description": "20 Bytes - address from which this log originated."
                                        },
                                        "logIndex": {
                                          "type": "string",
                                          "description": "Integer of the log index position in the block. null when its pending log."
                                        },
                                        "data": {
                                          "type": "string",
                                          "description": "Contains one or more 32 Bytes non-indexed arguments of the log."
                                        },
                                        "removed": {
                                          "type": "boolean",
                                          "description": "true when the log was removed, due to a chain reorganization. false if its a valid log."
                                        },
                                        "topics": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "description": "Array of zero to four 32 Bytes DATA of indexed log arguments. In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declare the event with the anonymous specifier."
                                        },
                                        "transactionHash": {
                                          "type": "string",
                                          "description": "Hash of the transactions this log was created from. null when its pending log."
                                        }
                                      }
                                    }
                                  ]
                                }
                              },
                              "logsBloom": {
                                "type": "string",
                                "description": "256 Bytes - Bloom filter for light clients to quickly retrieve related logs"
                              },
                              "root": {
                                "type": "string",
                                "description": "32 bytes of post-transaction stateroot (pre Byzantium)"
                              },
                              "status": {
                                "type": "integer",
                                "description": "Either 1 (success) or 0 (failure)",
                                "enum": [
                                  0,
                                  1
                                ]
                              },
                              "effectiveGasPrice": {
                                "type": "string"
                              },
                              "type": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        },
        "operationId": "sdk-getTransactionReceipts"
      }
    },
    "/{apiKey}/send": {
      "post": {
        "operationId": "sdk-send",
        "summary": "send",
        "description": "Allows sending a raw message to the Alchemy backend.",
        "tags": [
          "SDK Core Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "method": {
                        "type": "string",
                        "description": "The method to call."
                      },
                      "params": {
                        "type": "array",
                        "description": "The parameters to pass to the method."
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.core\n  .send(\"eth_getBlockByNumber\", [\"0xEDD023\", false])\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns an object corresponding to the method called.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "any"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getNftsForOwner": {
      "get": {
        "summary": "getNftsForOwner",
        "description": "Gets all NFTs currently owned by a given address.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "operationId": "sdk-getNfts",
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "owner",
            "description": "String - Address for NFT owner (can be in ENS format!).",
            "schema": {
              "type": "string"
            },
            "in": "query",
            "required": true
          },
          {
            "name": "pageKey",
            "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response. Pass back that pageKey as a param to fetch the next 100 NFTs.",
            "schema": {
              "type": "string"
            },
            "in": "query"
          },
          {
            "name": "pageSize",
            "description": "String - Number of NFTs to be returned per page. Defaults to 100. Max is 100. NOTE: Only supported on Ethereum Mainnet and Goerli, Polygon Mainnet and Mumbai, Arbitrum Mainnet and Goerli, and Optimism Mainnet and Goerli.",
            "schema": {
              "type": "integer"
            },
            "in": "query"
          },
          {
            "name": "contractAddresses[]",
            "description": "Array of contract addresses to filter the responses with. Max limit 20 contracts.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "in": "query"
          },
          {
            "name": "omitMetadata",
            "description": "Boolean - if set to `false`, returns NFT metadata. Setting this to true will reduce payload size and may result in a faster API call. Defaults to `false`.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "in": "query"
          },
          {
            "name": "tokenUriTimeoutInMs",
            "description": "No set timeout by default - When metadata is requested, this parameter is the timeout (in milliseconds) for the website hosting the metadata to respond. If you want to _only_ access the cache and not live fetch any metadata for cache misses then set this value to 0.",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "filters[]",
            "description": "Array of filters (as ENUMS) that will be applied to the query. NFTs that match one or more of these filters will be excluded from the response. Filter Options:\n  - SPAM: NFTs that have been classified as spam. Spam classification has a wide range of criteria that includes but is not limited to emitting fake events and copying other well-known NFTs.\n  - AIRDROPS: NFTs that have were airdropped to the user. Airdrops are defined as NFTs that were minted to a user address in a transaction sent by a different address. NOTE: this filter is currently supported on Ethereum Mainnet and Goerli only.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "SPAM",
                  "AIRDROPS"
                ]
              }
            },
            "in": "query"
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: demo, // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print all NFTs returned in the response:\nalchemy.nft.getNftsForOwner(\"0xshah.eth\").then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns true if transaction was successfully cancelled, false if not.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ownedNfts": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "contract": {
                            "description": "Object - Contract for returned NFT",
                            "type": "object",
                            "properties": {
                              "address": {
                                "type": "string",
                                "description": "String - Address of NFT contract."
                              }
                            }
                          },
                          "id": {
                            "type": "object",
                            "properties": {
                              "tokenId": {
                                "name": "tokenId",
                                "description": "String - The ID of the token. Can be in hex or decimal format.",
                                "in": "query",
                                "schema": {
                                  "type": "string",
                                  "default": "1"
                                },
                                "required": true
                              },
                              "tokenMetadata": {
                                "type": "object",
                                "properties": {
                                  "tokenType": {
                                    "type": "string",
                                    "description": "String - 'ERC721' or 'ERC1155'"
                                  }
                                }
                              }
                            }
                          },
                          "balance": {
                            "type": "string",
                            "description": "String - Token balance"
                          },
                          "title": {
                            "type": "string",
                            "description": "String - Name of the NFT asset."
                          },
                          "description": {
                            "type": "string",
                            "description": "String - Brief human-readable description"
                          },
                          "tokenUri": {
                            "type": "object",
                            "properties": {
                              "raw": {
                                "type": "string",
                                "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                              },
                              "gateway": {
                                "type": "string",
                                "description": "String - Public gateway uri for the raw uri above."
                              }
                            }
                          },
                          "media": {
                            "type": "object",
                            "properties": {
                              "raw": {
                                "type": "string",
                                "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                              },
                              "gateway": {
                                "type": "string",
                                "description": "String - Public gateway uri for the raw uri above."
                              },
                              "thumbnail": {
                                "type": "string",
                                "description": "URL for a resized thumbnail of the NFT media asset."
                              },
                              "format": {
                                "type": "string",
                                "description": "The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets."
                              },
                              "bytes": {
                                "type": "integer",
                                "description": "The size of the media asset in bytes."
                              }
                            }
                          },
                          "rawMetadata": {
                            "type": "object",
                            "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
                            "properties": {
                              "image": {
                                "type": "string",
                                "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
                              },
                              "external_url": {
                                "type": "string",
                                "description": "String - The image URL that appears alongside the asset image on NFT platforms."
                              },
                              "background_color": {
                                "type": "string",
                                "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
                              },
                              "name": {
                                "type": "string",
                                "description": "String - Name of the NFT asset."
                              },
                              "description": {
                                "type": "string",
                                "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
                              },
                              "attributes": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "value": {
                                      "type": "string"
                                    },
                                    "trait_type": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "description": "Object - Traits/attributes/characteristics for each NFT asset."
                              }
                            }
                          },
                          "timeLastUpdated": {
                            "type": "string",
                            "description": "String - ISO timestamp of the last cache refresh for the information returned in the metadata field."
                          },
                          "error": {
                            "type": "string",
                            "description": "String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT."
                          }
                        }
                      }
                    },
                    "pageKey": {
                      "type": "string",
                      "description": "String - UUID for pagination - returned if there are more NFTs to fetch. Max NFTs per page = 100."
                    },
                    "totalCount": {
                      "type": "string",
                      "description": "String - Total number of NFTs owned by the given address."
                    },
                    "blockHash": {
                      "type": "string",
                      "description": "String - The canonical head block hash of when your request was received"
                    }
                  }
                },
                "examples": {
                  "byDefault": {
                    "summary": "Response (By Default)",
                    "value": "{ \"ownedNfts\": [{\n    \"contract\": {\n      \"address\": \"0x0beed7099af7514ccedf642cfea435731176fb02\"\n    },\n    \"id\": {\n      \"tokenId\": \"28\",\n      \"tokenMetadata\": {\n        \"tokenType\": \"ERC721\"\n      }\n    },\n    \"title\": \"DuskBreaker #28\",\n    \"description\": \"Breakers have the honor of serving humanity through their work on The Dusk. They are part of a select squad of 10,000 recruits who spend their days exploring a mysterious alien spaceship filled with friends, foes, and otherworldly technology.\",\n    \"tokenUri\": {\n      \"raw\": \"https://duskbreakers.gg/api/breakers/28\",\n      \"gateway\": \"https://duskbreakers.gg/api/breakers/28\"\n    },\n    \"media\": [{\n      \"raw\": \"https://duskbreakers.gg/breaker_images/28.png\",\n      \"gateway\": \"https://duskbreakers.gg/breaker_images/28.png\"\n    }],\n    \"metadata\": {\n      \"name\": \"DuskBreaker #28\",\n      \"description\": \"Breakers have the honor of serving humanity through their work on The Dusk. They are part of a select squad of 10,000 recruits who spend their days exploring a mysterious alien spaceship filled with friends, foes, and otherworldly technology.\",\n      \"image\": \"https://duskbreakers.gg/breaker_images/28.png\",\n      \"external_url\": \"https://duskbreakers.gg\",\n      \"attributes\": [{\n          \"value\": \"Locust Rider Armor (Red)\",\n          \"trait_type\": \"Clothes\"\n        },\n        {\n          \"value\": \"Big Smile (Purple)\",\n          \"trait_type\": \"Mouth\"\n        },\n        {\n          \"value\": \"Yellow\",\n          \"trait_type\": \"Background\"\n        }\n      ]\n    },\n    \"timeLastUpdated\": \"2022-02-16T22:52:54.719Z\",\n    \"contractMetadata\": {\n      \"name\": \"DuskBreakers\",\n      \"symbol\": \"DUSK\",\n      \"totalSupply\": \"10000\",\n      \"tokenType\": \"ERC721\"\n    }\n  },\n  {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"5527\",\n      \"tokenMetadata\": {\n        \"tokenType\": \"ERC721\"\n      }\n    },\n    \"title\": \"Runner #5527\",\n    \"description\": \"Chain Runners are Mega City renegades 100% generated on chain.\",\n    \"tokenUri\": {\n      \"raw\": \"https://api.chainrunners.xyz/tokens/metadata/5527?dna=73247164192459371523281785218958151913554625578441142916970699984935810987041\",\n      \"gateway\": \"https://api.chainrunners.xyz/tokens/metadata/5527?dna=73247164192459371523281785218958151913554625578441142916970699984935810987041\"\n    },\n    \"media\": [{\n      \"raw\": \"https://img.chainrunners.xyz/api/v1/tokens/png/5527\",\n      \"gateway\": \"https://img.chainrunners.xyz/api/v1/tokens/png/5527\"\n    }],\n    \"metadata\": {\n      \"name\": \"Runner #5527\",\n      \"description\": \"Chain Runners are Mega City renegades 100% generated on chain.\",\n      \"image\": \"https://img.chainrunners.xyz/api/v1/tokens/png/5527\",\n      \"attributes\": [{\n          \"value\": \"Purple Green Diag\",\n          \"trait_type\": \"Background\"\n        },\n        {\n          \"value\": \"Human\",\n          \"trait_type\": \"Race\"\n        },\n        {\n          \"value\": \"Cig\",\n          \"trait_type\": \"Mouth Accessory\"\n        }\n      ]\n    },\n    \"timeLastUpdated\": \"2022-02-18T00:42:04.401Z\",\n    \"contractMetadata\": {\n      \"name\": \"Chain Runners\",\n      \"symbol\": \"RUN\",\n      \"totalSupply\": \"10000\",\n      \"tokenType\": \"ERC721\"\n    }\n  }],\n  \"totalCount\": 6,\n  \"blockHash\": \"0xeb2d26af5b6175344a14091777535a2cb21c681665a734a8285f889981987630\"\n}\n"
                  },
                  "withoutMetadata": {
                    "summary": "Response (withMetadata = false)",
                    "value": "{\n  \"ownedNfts\": [{\n      \"contract\": {\n        \"address\": \"0x0beed7099af7514ccedf642cfea435731176fb02\"\n      },\n      \"id\": {\n        \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000001c\"\n      }\n    },\n    {\n      \"contract\": {\n        \"address\": \"0x0beed7099af7514ccedf642cfea435731176fb02\"\n      },\n      \"id\": {\n        \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000001d\"\n      },\n      \"balance\": \"1\"\n    },\n    {\n      \"contract\": {\n        \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n      },\n      \"id\": {\n        \"tokenId\": \"0x0000000000000000000000000000000000000000000000000000000000001597\"\n      },\n      \"balance\": \"1\"\n    }\n  ],\n  \"totalCount\": 6,\n  \"blockHash\": \"0xf9a2a4e15116680e22b160c734529f62d89d54cde0759daf5135672fad0ecebc\"\n}\n"
                  },
                  "withContractFiltering": {
                    "summary": "Response (with contract filtering)",
                    "value": "{\n  \"ownedNfts\": [{\n    \"contract\": {\n      \"address\": \"0x34d77a17038491a2a9eaa6e690b7c7cd39fc8392\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x0000000000000000000000000000000000000000000000000000000000000277\"\n    }\n  }],\n  \"totalCount\": 1,\n  \"blockHash\": \"0x3d8bca59c08e41f55d46ebbe738327eb12955cf280bd06ef7d40352919c188d8\"\n}\n"
                  },
                  "withPagination": {
                    "summary": "Response (with pagination)",
                    "value": "{\n  \"ownedNfts\": [{\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x00000000000000000000000000000000000000000000000000000000000009cb\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x00000000000000000000000000000000000000000000000000000000000009cc\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x5ab21ec0bfa0b29545230395e3adaca7d552c948\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x00000000000000000000000000000000000000000000000000000000000006dc\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x3b3ee1931dc30c1957379fac9aba94d1c48a5405\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000001a\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x69c40e500b84660cb2ab09cb9614fa2387f95f64\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x0000000000000000000000000000000000000000000000000000000000000391\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x00000000000000000000000000000000000000000000000000000000000008d5\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x0000000000000000000000000000000000000000000000000000000000000a1d\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000002a\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000038e\"\n    }\n  }, {\n    \"contract\": {\n      \"address\": \"0x97597002980134bea46250aa0510c9b90d87a587\"\n    },\n    \"id\": {\n      \"tokenId\": \"0x000000000000000000000000000000000000000000000000000000000000244b\"\n    }\n  }],\n  \"pageKey\": \"88434286-7eaa-472d-8739-32a0497c2a18\",\n  \"totalCount\": 277,\n  \"blockHash\": \"0x94d5ab52b8a6571733f6b183ef89f31573b82a4e78f8129b0ce90ef0beaf208b\"\n}\n"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getNftMetadata": {
      "get": {
        "summary": "getNftMetadata",
        "description": "Gets the metadata associated with a given NFT.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "tokenId",
            "description": "String - The ID of the token. Can be in hex or decimal format.",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "1"
            },
            "required": true
          },
          {
            "name": "tokenType",
            "description": "String - 'ERC721' or 'ERC1155'; specifies type of token to query for. API requests will perform faster if this is specified.",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tokenUriTimeoutInMs",
            "description": "No set timeout by default - When metadata is requested, this parameter is the timeout (in milliseconds) for the website hosting the metadata to respond. If you want to _only_ access the cache and not live fetch any metadata for cache misses then set this value to 0.",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "refreshCache",
            "description": "Defaults to false for faster response times.  If true will refresh metadata for given token. If false will check the cache and use it or refresh if cache doesn't exist.",
            "in": "query",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print NFT metadata returned in the response:\nalchemy.nft.getNftMetadata(\n  \"0x5180db8F5c931aaE63c74266b211F580155ecac8\",\n  \"1590\"\n).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contract": {
                      "description": "Object - Contract for returned NFT",
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string",
                          "description": "String - Address of NFT contract."
                        }
                      }
                    },
                    "id": {
                      "type": "object",
                      "properties": {
                        "tokenId": {
                          "name": "tokenId",
                          "description": "String - The ID of the token. Can be in hex or decimal format.",
                          "in": "query",
                          "schema": {
                            "type": "string",
                            "default": "1"
                          },
                          "required": true
                        },
                        "tokenMetadata": {
                          "type": "object",
                          "properties": {
                            "tokenType": {
                              "type": "string",
                              "description": "String - 'ERC721' or 'ERC1155'"
                            }
                          }
                        }
                      }
                    },
                    "balance": {
                      "type": "string",
                      "description": "String - Token balance"
                    },
                    "title": {
                      "type": "string",
                      "description": "String - Name of the NFT asset."
                    },
                    "description": {
                      "type": "string",
                      "description": "String - Brief human-readable description"
                    },
                    "tokenUri": {
                      "type": "object",
                      "properties": {
                        "raw": {
                          "type": "string",
                          "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                        },
                        "gateway": {
                          "type": "string",
                          "description": "String - Public gateway uri for the raw uri above."
                        }
                      }
                    },
                    "media": {
                      "type": "object",
                      "properties": {
                        "raw": {
                          "type": "string",
                          "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                        },
                        "gateway": {
                          "type": "string",
                          "description": "String - Public gateway uri for the raw uri above."
                        },
                        "thumbnail": {
                          "type": "string",
                          "description": "URL for a resized thumbnail of the NFT media asset."
                        },
                        "format": {
                          "type": "string",
                          "description": "The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets."
                        },
                        "bytes": {
                          "type": "integer",
                          "description": "The size of the media asset in bytes."
                        }
                      }
                    },
                    "rawMetadata": {
                      "type": "object",
                      "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
                      "properties": {
                        "image": {
                          "type": "string",
                          "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
                        },
                        "external_url": {
                          "type": "string",
                          "description": "String - The image URL that appears alongside the asset image on NFT platforms."
                        },
                        "background_color": {
                          "type": "string",
                          "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
                        },
                        "name": {
                          "type": "string",
                          "description": "String - Name of the NFT asset."
                        },
                        "description": {
                          "type": "string",
                          "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
                        },
                        "attributes": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "value": {
                                "type": "string"
                              },
                              "trait_type": {
                                "type": "string"
                              }
                            }
                          },
                          "description": "Object - Traits/attributes/characteristics for each NFT asset."
                        }
                      }
                    },
                    "timeLastUpdated": {
                      "type": "string",
                      "description": "String - ISO timestamp of the last cache refresh for the information returned in the metadata field."
                    },
                    "error": {
                      "type": "string",
                      "description": "String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT."
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getNftMetadata"
      }
    },
    "/{apiKey}/getNftMetadataBatch": {
      "get": {
        "summary": "getNftMetadataBatch",
        "description": "Gets the metadata for a batch of NFTs.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "tokens",
            "in": "query",
            "description": "List of token objects to batch request NFT metadata for. Maximum 100.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "contractAddress",
                  "tokenId"
                ],
                "properties": {
                  "contractAddress": {
                    "type": "string",
                    "description": "The contract address of the NFT."
                  },
                  "tokenId": {
                    "type": "string",
                    "description": "The unique identifier of the NFT."
                  },
                  "tokenType": {
                    "type": "string",
                    "description": "The type of the NFT, such as ERC721.",
                    "nullable": true
                  }
                }
              }
            }
          },
          {
            "name": "options",
            "in": "query",
            "description": "An object with the following properties: tokenUriTimeoutInMs, refreshCache.",
            "required": false,
            "schema": {
              "type": "object",
              "properties": {
                "tokenUriTimeoutInMs": {
                  "type": "integer",
                  "description": "The amount of time in milliseconds to wait before timing out when trying to fetch the token URI."
                },
                "refreshCache": {
                  "type": "boolean",
                  "description": "Whether to refresh the cache before returning the metadata."
                }
              }
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print NFT metadata returned in the response:\nalchemy.nft.getNftMetadataBatch(\n  [\n    {\n      contractAddress: \"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\",\n      tokenId: \"3\",\n      tokenType: \"ERC721\"\n    },\n    {\n      contractAddress: \"0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e\",\n      tokenId: \"4\",\n      tokenType: \"ERC721\"\n    }\n  ],\n  {\n    tokenUriTimeoutInMs: 5000,\n    refreshCache: true\n  }\n).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "contract",
                      "tokenId",
                      "tokenType",
                      "title",
                      "description",
                      "timeLastUpdated"
                    ],
                    "properties": {
                      "contract": {
                        "type": "object",
                        "required": [
                          "address",
                          "name",
                          "symbol",
                          "totalSupply",
                          "tokenType"
                        ],
                        "properties": {
                          "address": {
                            "type": "string",
                            "description": "The contract address of the NFT."
                          },
                          "name": {
                            "type": "string",
                            "description": "The name of the NFT contract."
                          },
                          "symbol": {
                            "type": "string",
                            "description": "The symbol of the NFT contract."
                          },
                          "totalSupply": {
                            "type": "string",
                            "description": "The total supply of the NFT contract."
                          },
                          "tokenType": {
                            "type": "string",
                            "description": "The type of the NFT contract, such as ERC721."
                          }
                        }
                      },
                      "tokenId": {
                        "type": "string",
                        "description": "The unique identifier of the NFT."
                      },
                      "tokenType": {
                        "type": "string",
                        "description": "The type of the NFT, such as ERC721."
                      },
                      "title": {
                        "type": "string",
                        "description": "The title of the NFT.",
                        "nullable": true
                      },
                      "description": {
                        "type": "string",
                        "description": "The description of the NFT.",
                        "nullable": true
                      },
                      "timeLastUpdated": {
                        "type": "string",
                        "format": "date-time",
                        "description": "The time when the metadata was last updated."
                      },
                      "metadataError": {
                        "type": "string",
                        "description": "An error message if there was a problem fetching the metadata.",
                        "nullable": true
                      },
                      "rawMetadata": {
                        "type": "object",
                        "description": "The raw metadata of the NFT.",
                        "nullable": true,
                        "properties": {
                          "image": {
                            "type": "string",
                            "description": "The IPFS hash of the image associated with the NFT."
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "required": [
                                "key",
                                "value"
                              ],
                              "properties": {
                                "key": {
                                  "type": "string",
                                  "description": "The key of the attribute."
                                },
                                "value": {
                                  "type": "string",
                                  "description": "The value of the attribute."
                                }
                              }
                            }
                          }
                        }
                      },
                      "tokenUri": {
                        "type": "object",
                        "description": "The URI of the NFT.",
                        "nullable": true,
                        "properties": {
                          "raw": {
                            "type": "string",
                            "description": "The raw URI of the NFT."
                          },
                          "gateway": {
                            "type": "string",
                            "description": "The URI of the NFT accessed through a gateway."
                          }
                        }
                      },
                      "media": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": [
                            "url"
                          ],
                          "properties": {
                            "url": {
                              "type": "string",
                              "description": "The URL of the media.",
                              "nullable": true
                            }
                          }
                        }
                      },
                      "spamInfo": {
                        "type": "object",
                        "description": "Information about whether the NFT has been flagged as spam.",
                        "nullable": true
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getNftMetadataBatch"
      }
    },
    "/{apiKey}/refreshNftMetadata": {
      "post": {
        "summary": "refreshNftMetadata",
        "description": "Refreshes the metadata for a given NFT.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "tokenId",
            "description": "String - The ID of the token. Can be in hex or decimal format.",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "1"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Refresh NFT Metadata for a given NFT contract address and token ID.\nalchemy.nft\n  .refreshNftMetadata(\"0x06012c8cf97bead5deae237070f9587f8e7a266d\", \"1\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean",
                  "description": "Indicates whether the metadata was refreshed."
                }
              }
            }
          }
        },
        "operationId": "sdk-refreshNftMetadata"
      }
    },
    "/{apiKey}/getNftSales": {
      "get": {
        "summary": "getNftSales",
        "description": "Gets a list of NFT sales that have happened through on-chain marketplaces.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "options",
            "in": "query",
            "schema": {
              "type": "object",
              "properties": {
                "buyerAddress": {
                  "type": "string",
                  "description": "The address of the NFT buyer to filter sales by."
                },
                "fromBlock": {
                  "type": "integer",
                  "description": "The block number to start fetching NFT sales data from."
                },
                "limit": {
                  "type": "integer",
                  "description": "The maximum number of NFT sales to return."
                },
                "marketplace": {
                  "type": "string",
                  "description": "The on-chain marketplace to filter sales by."
                },
                "order": {
                  "type": "string",
                  "description": "Whether to return the results in ascending or descending order by block number.",
                  "enum": [
                    "asc",
                    "desc"
                  ]
                },
                "pageKey": {
                  "type": "string",
                  "description": "The pagination key for the next page of results."
                },
                "sellerAddress": {
                  "type": "string",
                  "description": "The address of the NFT seller to filter sales by."
                },
                "taker": {
                  "type": "string",
                  "description": "Whether the buyer or seller was the taker in the sale.",
                  "enum": [
                    "buyer",
                    "seller"
                  ]
                },
                "toBlock": {
                  "type": "integer",
                  "description": "The block number to stop fetching NFT sales data at."
                }
              }
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print NFT sales returned in the response:\nalchemy.nft\n  .getNftSales()\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "pageKey": {
                      "type": "string",
                      "description": "The pagination key for the next page of results, if available."
                    },
                    "nftSales": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "marketplace": {
                            "type": "string",
                            "description": "The on-chain marketplace where the sale took place."
                          },
                          "contractAddress": {
                            "type": "string",
                            "description": "The contract address of the NFT."
                          },
                          "tokenId": {
                            "type": "string",
                            "description": "The token id of the NFT."
                          },
                          "quantity": {
                            "type": "string",
                            "description": "The quantity of NFTs sold in the sale."
                          },
                          "buyerAddress": {
                            "type": "string",
                            "description": "The address of the NFT buyer."
                          },
                          "sellerAddress": {
                            "type": "string",
                            "description": "The address of the NFT seller."
                          },
                          "taker": {
                            "type": "string",
                            "description": "Whether the buyer or seller was the taker in the sale.",
                            "enum": [
                              "buyer",
                              "seller"
                            ]
                          },
                          "sellerFee": {
                            "type": "object",
                            "description": "The fee paid by the seller in the sale.",
                            "properties": {
                              "amount": {
                                "type": "string",
                                "description": "The amount of the fee."
                              },
                              "currency": {
                                "type": "string",
                                "description": "The currency of the fee.",
                                "enum": [
                                  "eth"
                                ]
                              }
                            }
                          },
                          "marketplaceFee": {
                            "type": "object",
                            "description": "The fee paid to the marketplace in the sale, if applicable.",
                            "properties": {
                              "amount": {
                                "type": "string",
                                "description": "The amount of the fee."
                              },
                              "currency": {
                                "type": "string",
                                "description": "The currency of the fee.",
                                "enum": [
                                  "eth"
                                ]
                              }
                            }
                          },
                          "royaltyFee": {
                            "type": "object",
                            "description": "The royalty fee paid in the sale, if applicable.",
                            "properties": {
                              "amount": {
                                "type": "string",
                                "description": "The amount of the fee."
                              },
                              "currency": {
                                "type": "string",
                                "description": "The currency of the fee.",
                                "enum": [
                                  "eth"
                                ]
                              }
                            }
                          },
                          "blockNumber": {
                            "type": "integer",
                            "description": "The block number where the sale took place."
                          },
                          "logIndex": {
                            "type": "integer",
                            "description": "The log index of the sale in the block."
                          },
                          "bundleIndex": {
                            "type": "integer",
                            "description": "The bundle index of the sale."
                          },
                          "transactionHash": {
                            "type": "string",
                            "description": "The transaction hash of the sale."
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getNftSales"
      }
    },
    "/{apiKey}/summarizeNftAttributes": {
      "get": {
        "summary": "summarizeNftAttributes",
        "description": "Generate a summary of attribute prevalence for an NFT collection.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Get the summary of attribute prevalence for the given NFT collection.\nalchemy.nft\n  .summarizeNftAttributes(\"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Prevalence counts for each attribute within a collection.",
                  "properties": {
                    "totalSupply": {
                      "type": "number",
                      "description": "Total number of NFTs for the input contract."
                    },
                    "summary": {
                      "type": "object",
                      "description": "Object mapping trait types to the prevalence of each trait within that type."
                    },
                    "contract": {
                      "name": "contractAddress",
                      "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
                      "in": "query",
                      "schema": {
                        "type": "string",
                        "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
                      },
                      "required": true
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-summarizeNftAttributes"
      }
    },
    "/{apiKey}/searchContractMetadata": {
      "get": {
        "summary": "searchContractMetadata",
        "description": "Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string",
              "description": "The search string that you want to search for in contract metadata."
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "description": "An array of object containing information about the NFT contracts whose metadata matches with the given query.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "description": "Address of the NFT contract."
                      },
                      "name": {
                        "type": "string",
                        "description": "Name of the NFT contract."
                      },
                      "symbol": {
                        "type": "string",
                        "description": "Symbol of the NFT contract."
                      },
                      "totalSupply": {
                        "type": "string",
                        "description": "Total supply of NFTs for the contract."
                      },
                      "tokenType": {
                        "type": "string",
                        "description": "Type of the NFT contract, either \"ERC721\" or \"ERC1155\"."
                      },
                      "openSea": {
                        "type": "object",
                        "description": "OpenSea metadata for the NFT contract.",
                        "properties": {
                          "floorPrice": {
                            "type": "number",
                            "description": "Minimum price for an NFT to be sold on OpenSea."
                          },
                          "collectionName": {
                            "type": "string",
                            "description": "Name of the collection on OpenSea."
                          },
                          "safelistRequestStatus": {
                            "type": "string",
                            "description": "Current status of the contract's safelist request on OpenSea."
                          },
                          "imageUrl": {
                            "type": "string",
                            "description": "URL of the main image for the NFT contract."
                          },
                          "description": {
                            "type": "string",
                            "description": "Description of the NFT contract."
                          },
                          "externalUrl": {
                            "type": "string",
                            "description": "External URL of the NFT contract."
                          },
                          "twitterUsername": {
                            "type": "string",
                            "description": "Twitter username for the NFT contract."
                          },
                          "discordUrl": {
                            "type": "string",
                            "description": "URL for the NFT contract's Discord server."
                          },
                          "lastIngestedAt": {
                            "type": "string",
                            "description": "Timestamp of the last time the contract's metadata was updated on OpenSea."
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Search for \"hair\" string across metadata of all NFT collections.\nalchemy.nft.searchContractMetadata(\"hair\").then(console.log);\n"
            }
          ]
        },
        "operationId": "sdk-searchContractMetadata"
      }
    },
    "/{apiKey}/getNftsForOwnerIterator": {
      "get": {
        "summary": "getNftsForOwnerIterator",
        "description": "Fetches all NFTs for a given owner and yields them in an async iterable.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "owner",
            "in": "query",
            "required": true,
            "description": "The address of the owner.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "options",
            "in": "query",
            "required": false,
            "description": "The optional parameters to use for the request.",
            "schema": {
              "type": "object",
              "properties": {
                "contractAddresses": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "Optional list of contract addresses to filter the results by. Limit is 20."
                  }
                },
                "excludeFilters": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "description": "Optional list of filters applied to the query. NFTs that match one or more of these filters are excluded from the response."
                  }
                },
                "omitMetadata": {
                  "type": "boolean",
                  "description": "Optional boolean flag to omit NFT metadata. Defaults to false."
                },
                "pageKey": {
                  "type": "string",
                  "description": "A page key returned in a previous response to request the next page of results."
                },
                "pageSize": {
                  "type": "integer",
                  "description": "The number of results to return per page."
                },
                "tokenUriTimeoutInMs": {
                  "type": "integer",
                  "description": "Timeout for the `tokenURI` field in the returned `OwnedNFT` objects."
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "contract": {
                        "description": "Object - Contract for returned NFT",
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string",
                            "description": "String - Address of NFT contract."
                          }
                        }
                      },
                      "id": {
                        "type": "object",
                        "properties": {
                          "tokenId": {
                            "name": "tokenId",
                            "description": "String - The ID of the token. Can be in hex or decimal format.",
                            "in": "query",
                            "schema": {
                              "type": "string",
                              "default": "1"
                            },
                            "required": true
                          },
                          "tokenMetadata": {
                            "type": "object",
                            "properties": {
                              "tokenType": {
                                "type": "string",
                                "description": "String - 'ERC721' or 'ERC1155'"
                              }
                            }
                          }
                        }
                      },
                      "balance": {
                        "type": "string",
                        "description": "String - Token balance"
                      },
                      "title": {
                        "type": "string",
                        "description": "String - Name of the NFT asset."
                      },
                      "description": {
                        "type": "string",
                        "description": "String - Brief human-readable description"
                      },
                      "tokenUri": {
                        "type": "object",
                        "properties": {
                          "raw": {
                            "type": "string",
                            "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                          },
                          "gateway": {
                            "type": "string",
                            "description": "String - Public gateway uri for the raw uri above."
                          }
                        }
                      },
                      "media": {
                        "type": "object",
                        "properties": {
                          "raw": {
                            "type": "string",
                            "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                          },
                          "gateway": {
                            "type": "string",
                            "description": "String - Public gateway uri for the raw uri above."
                          },
                          "thumbnail": {
                            "type": "string",
                            "description": "URL for a resized thumbnail of the NFT media asset."
                          },
                          "format": {
                            "type": "string",
                            "description": "The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets."
                          },
                          "bytes": {
                            "type": "integer",
                            "description": "The size of the media asset in bytes."
                          }
                        }
                      },
                      "rawMetadata": {
                        "type": "object",
                        "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
                        "properties": {
                          "image": {
                            "type": "string",
                            "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
                          },
                          "external_url": {
                            "type": "string",
                            "description": "String - The image URL that appears alongside the asset image on NFT platforms."
                          },
                          "background_color": {
                            "type": "string",
                            "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
                          },
                          "name": {
                            "type": "string",
                            "description": "String - Name of the NFT asset."
                          },
                          "description": {
                            "type": "string",
                            "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "value": {
                                  "type": "string"
                                },
                                "trait_type": {
                                  "type": "string"
                                }
                              }
                            },
                            "description": "Object - Traits/attributes/characteristics for each NFT asset."
                          }
                        }
                      },
                      "timeLastUpdated": {
                        "type": "string",
                        "description": "String - ISO timestamp of the last cache refresh for the information returned in the metadata field."
                      },
                      "error": {
                        "type": "string",
                        "description": "String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT."
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// define the owner address whose NFTs you want to fetch\nconst owner = \"0xe5cb067e90d5cd1f8052b83562ae670ba4a211a8\";\n\n// create an async generator function that uses the getNftsForOwnerIterator method\nasync function getNftsForOwner() {\n  try {\n    let nfts = [];\n    // Get the async iterable for the owner's NFTs.\n    const nftsIterable = alchemy.nft.getNftsForOwnerIterator(owner);\n    \n    // Iterate over the NFTs and add them to the nfts array.\n    for await (const nft of nftsIterable) {\n      nfts.push(nft);\n    }\n\n    // Log the NFTs.\n    console.log(nfts);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n// call the async generator function\ngetNftsForOwner();\n"
            }
          ]
        },
        "operationId": "sdk-getNftsForOwnerIterator"
      }
    },
    "/{apiKey}/getNftsForContractIterator": {
      "get": {
        "summary": "getNftsForContractIterator",
        "description": "Fetches all NFTs for a given contract address and yields them in an async iterable.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "options",
            "in": "query",
            "required": false,
            "description": "The optional parameters to use for the request.",
            "schema": {
              "type": "object",
              "properties": {
                "omitMetadata": {
                  "type": "boolean",
                  "description": "Optional boolean flag to omit NFT metadata. Defaults to false."
                },
                "pageKey": {
                  "type": "string",
                  "description": "A page key returned in a previous response to request the next page of results."
                },
                "pageSize": {
                  "type": "integer",
                  "description": "Sets the total number of NFTs to return in the response. Defaults to 100. Maximum page size is 100."
                },
                "tokenUriTimeoutInMs": {
                  "type": "integer",
                  "description": "No set timeout by default - When metadata is requested, this parameter is the timeout (in milliseconds) for the website hosting the metadata to respond. If you want to only access the cache and not live fetch any metadata for cache misses then set this value to 0."
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "contract": {
                        "description": "Object - Contract for returned NFT",
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string",
                            "description": "String - Address of NFT contract."
                          }
                        }
                      },
                      "id": {
                        "type": "object",
                        "properties": {
                          "tokenId": {
                            "name": "tokenId",
                            "description": "String - The ID of the token. Can be in hex or decimal format.",
                            "in": "query",
                            "schema": {
                              "type": "string",
                              "default": "1"
                            },
                            "required": true
                          },
                          "tokenMetadata": {
                            "type": "object",
                            "properties": {
                              "tokenType": {
                                "type": "string",
                                "description": "String - 'ERC721' or 'ERC1155'"
                              }
                            }
                          }
                        }
                      },
                      "balance": {
                        "type": "string",
                        "description": "String - Token balance"
                      },
                      "title": {
                        "type": "string",
                        "description": "String - Name of the NFT asset."
                      },
                      "description": {
                        "type": "string",
                        "description": "String - Brief human-readable description"
                      },
                      "tokenUri": {
                        "type": "object",
                        "properties": {
                          "raw": {
                            "type": "string",
                            "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                          },
                          "gateway": {
                            "type": "string",
                            "description": "String - Public gateway uri for the raw uri above."
                          }
                        }
                      },
                      "media": {
                        "type": "object",
                        "properties": {
                          "raw": {
                            "type": "string",
                            "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                          },
                          "gateway": {
                            "type": "string",
                            "description": "String - Public gateway uri for the raw uri above."
                          },
                          "thumbnail": {
                            "type": "string",
                            "description": "URL for a resized thumbnail of the NFT media asset."
                          },
                          "format": {
                            "type": "string",
                            "description": "The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets."
                          },
                          "bytes": {
                            "type": "integer",
                            "description": "The size of the media asset in bytes."
                          }
                        }
                      },
                      "rawMetadata": {
                        "type": "object",
                        "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
                        "properties": {
                          "image": {
                            "type": "string",
                            "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
                          },
                          "external_url": {
                            "type": "string",
                            "description": "String - The image URL that appears alongside the asset image on NFT platforms."
                          },
                          "background_color": {
                            "type": "string",
                            "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
                          },
                          "name": {
                            "type": "string",
                            "description": "String - Name of the NFT asset."
                          },
                          "description": {
                            "type": "string",
                            "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "value": {
                                  "type": "string"
                                },
                                "trait_type": {
                                  "type": "string"
                                }
                              }
                            },
                            "description": "Object - Traits/attributes/characteristics for each NFT asset."
                          }
                        }
                      },
                      "timeLastUpdated": {
                        "type": "string",
                        "description": "String - ISO timestamp of the last cache refresh for the information returned in the metadata field."
                      },
                      "error": {
                        "type": "string",
                        "description": "String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT."
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// define the contract address whose NFTs you want to fetch\nconst contractAddress = \"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\";\n\n// create an async generator function that uses the getNftsForContractIterator method\nasync function getNftsForContract() {\n  try {\n    let nfts = [];\n    // Get the async iterable for the contract's NFTs.\n    alchemy.nft.getNftsForContractIterator(contractAddress);\n    \n    // Iterate over the NFTs and add them to the nfts array.\n    for await (const nft of nftsIterable) {\n      nfts.push(nft);\n    }\n\n    // Log the NFTs.\n    console.log(nfts);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n// call the async generator function\ngetNftsForContract();\n"
            }
          ]
        },
        "operationId": "sdk-getNftsForContractIterator"
      }
    },
    "/{apiKey}/getContractMetadata": {
      "get": {
        "summary": "getContractMetadata",
        "description": "Queries NFT high-level collection/contract level information.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nalchemy.nft\n  .getContractMetadata(\"0x61fce80d72363b731425c3a2a46a1a5fed9814b2\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "String - Contract address for the queried NFT collection"
                    },
                    "contractMetadata": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "description": "String - NFT contract name."
                        },
                        "symbol": {
                          "type": "string",
                          "description": "String - NFT contract symbol abbreviation."
                        },
                        "totalSupply": {
                          "type": "string",
                          "description": "String - Total number of NFTs in a given NFT collection."
                        },
                        "tokenType": {
                          "type": "string",
                          "description": "String - 'ERC721' or 'ERC1155'"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getContractMetadata"
      }
    },
    "/{apiKey}/getNftsForContract": {
      "get": {
        "summary": "getNftsForContract",
        "description": "Gets all NFTs for a given NFT contract.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "omitMetadata",
            "description": "Boolean - if set to `false`, returns NFT metadata. Setting this to true will reduce payload size and may result in a faster API call. Defaults to `false`.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "in": "query"
          },
          {
            "name": "startToken",
            "description": "String - An offset used for pagination. Can be a hex string, or a decimal. Set to `nextToken` returned in the response to access the next page.",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "description": "Integer - Sets the total number of NFTs returned in the response. Defaults to 100.",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "tokenUriTimeoutInMs",
            "description": "No set timeout by default - When metadata is requested, this parameter is the timeout (in milliseconds) for the website hosting the metadata to respond. If you want to _only_ access the cache and not live fetch any metadata for cache misses then set this value to 0.",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print total NFT collection returned in the response:\nalchemy.nft\n  .getNftsForContract(\"0x61fce80d72363b731425c3a2a46a1a5fed9814b2\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nfts": {
                      "description": "List of objects that represent NFTs stored under the queried contract address.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "object",
                            "properties": {
                              "tokenId": {
                                "name": "tokenId",
                                "description": "String - The ID of the token. Can be in hex or decimal format.",
                                "in": "query",
                                "schema": {
                                  "type": "string",
                                  "default": "1"
                                },
                                "required": true
                              },
                              "tokenMetadata": {
                                "type": "object",
                                "properties": {
                                  "tokenType": {
                                    "type": "string",
                                    "description": "String - 'ERC721' or 'ERC1155'"
                                  }
                                }
                              }
                            }
                          },
                          "tokenUri": {
                            "type": "object",
                            "properties": {
                              "raw": {
                                "type": "string",
                                "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
                              },
                              "gateway": {
                                "type": "string",
                                "description": "String - Public gateway uri for the raw uri above."
                              }
                            }
                          },
                          "rawMetadata": {
                            "type": "object",
                            "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
                            "properties": {
                              "image": {
                                "type": "string",
                                "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
                              },
                              "external_url": {
                                "type": "string",
                                "description": "String - The image URL that appears alongside the asset image on NFT platforms."
                              },
                              "background_color": {
                                "type": "string",
                                "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
                              },
                              "name": {
                                "type": "string",
                                "description": "String - Name of the NFT asset."
                              },
                              "description": {
                                "type": "string",
                                "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
                              },
                              "attributes": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "value": {
                                      "type": "string"
                                    },
                                    "trait_type": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "description": "Object - Traits/attributes/characteristics for each NFT asset."
                              }
                            }
                          }
                        }
                      }
                    },
                    "nextToken": {
                      "type": "string",
                      "description": "String - An offset used for pagination"
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getNftsForContract"
      }
    },
    "/{apiKey}/getOwnersForNft": {
      "get": {
        "summary": "getOwnersForNft",
        "description": "Get the owner(s) for a token.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "tokenId",
            "description": "String - The ID of the token. Can be in hex or decimal format.",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "1"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print total NFT count returned in the response:\nalchemy.nft.getOwnersForNft(\"0x5180db8F5c931aaE63c74266b211F580155ecac8\", \"1590\").then(\n  console.log\n);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "owners": {
                      "type": "object",
                      "properties": {
                        "ownerAddresses": {
                          "description": "List of all addresses that own one of the NFTs from the queried contract address.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/getOwnersForContract": {
      "get": {
        "summary": "getOwnersForContract",
        "description": "Gets all owners for a given NFT contract.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "withTokenBalances",
            "description": "Boolean - If set to `true` the query will include the token balances per token id for each owner. `false` by default.",
            "in": "query",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "block",
            "description": "String - The point in time or block number (in hex or decimal) to fetch collection ownership information for.",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "required": false
          },
          {
            "name": "pageKey",
            "description": "String - used for collections with >50,000 owners. `pageKey` field can be passed back as request parameter to get the next page of results.",
            "schema": {
              "type": "string"
            },
            "in": "query"
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print total NFT count returned in the response:\nalchemy.nft\n  .getOwnersForContract(\"0x61fce80d72363b731425c3a2a46a1a5fed9814b2\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ownerAddresses": {
                      "description": "List of all addresses that own one of the NFTs from the queried contract address.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getOwnersForContract"
      }
    },
    "/{apiKey}/getSpamContracts": {
      "get": {
        "summary": "getSpamContracts",
        "description": "Returns a list of all spam contracts marked by Alchemy.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print all spam NFT contracts returned in the response:\nalchemy.nft.getSpamContracts().then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "A list of contract addresses earmarked as spam by Alchemy."
                }
              }
            }
          }
        },
        "operationId": "sdk-getSpamContracts"
      }
    },
    "/{apiKey}/isSpamContract": {
      "get": {
        "summary": "isSpamContract",
        "description": "Returns whether a contract is marked as spam or not by Alchemy.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print whether an NFT contract is spam\nalchemy.nft\n  .isSpamContract(\"0x000440f08436a7b866d1ae42db5e0be801da722a\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean",
                  "description": "<br/> True - if the queried contract is marked as spam. <br/> False - if the queried contract is considered valid."
                }
              }
            }
          }
        },
        "operationId": "sdk-isSpamContract"
      }
    },
    "/{apiKey}/refreshContract": {
      "get": {
        "summary": "refreshContract",
        "description": "Triggers metadata refresh for an entire NFT collection and refreshes stale metadata after a collection reveal/collection changes.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport {\n  Network,\n} from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print total NFT count returned in the response:\nalchemy.nft.refreshContract(\n  \"0x5180db8F5c931aaE63c74266b211F580155ecac8\",\n  \"1590\"\n).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contractAddresses": {
                      "name": "contractAddresses[]",
                      "description": "Array of contract addresses to filter the responses with. Max limit 20 contracts.",
                      "schema": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "in": "query"
                    },
                    "reingestionState": {
                      "type": "string",
                      "enum": [
                        "does_not_exist",
                        "already_queried",
                        "in_progress",
                        "finished",
                        "queued",
                        "queue_failed"
                      ],
                      "description": "<br/> String - The current state of the reingestion request. <br/>'does_not_exist' - The contract requested is not an NFT and does not contain proper metadata <br/>'already_queried' - Contract already queried <br/>'in_progress' - Ingestion in progress <br/>'finished' - Ingestion complete <br/>'queued' - Ingestion request placed into queue and awaiting execution. <br/>'queue_failed' - Queue job incomplete"
                    },
                    "progress": {
                      "type": "string",
                      "description": "String - Percentage of tokens successfully refreshed."
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-refreshContract"
      }
    },
    "/{apiKey}/getFloorPrice": {
      "get": {
        "summary": "getFloorPrice",
        "description": "Returns the floor prices of a NFT collection by marketplace.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\n// Print the NFT floor price for a contract\nalchemy.nft\n  .getFloorPrice(\"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nftMarketplace": {
                      "type": "object",
                      "description": "Name of the NFT marketplace where the collection is listed. Current marketplaces supported -  OpenSea, LooksRare",
                      "properties": {
                        "floorPrice": {
                          "type": "number",
                          "description": "Number - The floor price of the collection on the given marketplace."
                        },
                        "priceCurrency": {
                          "type": "string",
                          "description": "String - The currency in which the floor price is denominated. Typically, denominated in ETH",
                          "enum": [
                            "ETH"
                          ]
                        },
                        "collectionUrl": {
                          "type": "string",
                          "description": "String - Link to the collection on the given marketplace."
                        },
                        "retrievedAt": {
                          "type": "string",
                          "description": "String - UTC timestamp of when the floor price was retrieved from the marketplace."
                        },
                        "error": {
                          "type": "string",
                          "description": "String - Returns an error if there was an error fetching floor prices from the given marketplace."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-getFloorPrice"
      }
    },
    "/{apiKey}/computeRarity": {
      "get": {
        "summary": "computeRarity",
        "description": "Computes the rarity of each attribute of an NFT.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          },
          {
            "name": "tokenId",
            "description": "String - The ID of the token. Can be in hex or decimal format.",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "1"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nalchemy.nft\n  .computeRarity(\"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\", 145)\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "description": "NFT attributes and their associated prevalence.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "trait_type": {
                        "type": "string",
                        "description": "Name of the trait category, i.e. Hat, Color, Face, etc."
                      },
                      "value": {
                        "type": "string",
                        "description": "Value for the trait, i.e. White Cap, Blue, Angry, etc."
                      },
                      "prevalence": {
                        "type": "number",
                        "description": "Floating point value from 0 to 1 representing the prevalence of this value for this trait type."
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-computeRarity"
      }
    },
    "/{apiKey}/verifyNftOwnership": {
      "get": {
        "summary": "verifyNftOwnership",
        "description": "Checks if the given address holds an NFT from the given NFT contract.",
        "tags": [
          "SDK NFT Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          },
          {
            "name": "walletAddress",
            "description": "String - Wallet address",
            "schema": {
              "type": "string",
              "default": "0xe5cB067E90D5Cd1F8052B83562Ae670bA4A211a8"
            },
            "required": true,
            "in": "query"
          },
          {
            "name": "contractAddress",
            "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
            },
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Github: https://github.com/alchemyplatform/alchemy-sdk-js\n// Setup: npm install alchemy-sdk\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional Config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nalchemy.nft\n  .verifyNftOwnership(\"0xe5cB067E90D5Cd1F8052B83562Ae670bA4A211a8\", \"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\")\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean",
                  "description": "Boolean representing if the given contract address holds an NFT from the given NFT contract."
                }
              }
            }
          }
        },
        "operationId": "sdk-verifyNftOwnership"
      }
    },
    "/{apiKey}/getTransaction": {
      "post": {
        "operationId": "sdk-getTransaction",
        "summary": "getTransaction",
        "description": "Returns the information about a transaction requested by transaction hash or number. In the response object, `blockHash`, `blockNumber`, and `transactionIndex` are `null` when the transaction is pending.",
        "tags": [
          "SDK Transact Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "example": {
                  "params": [
                    "0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b"
                  ]
                },
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "String - 32 Bytes - Hash of a transaction",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.transact\n  .getTransaction(\n    \"0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "description": "A transaction object, or null when no transaction was found",
                          "allOf": [
                            {
                              "type": "object",
                              "properties": {
                                "blockHash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                },
                                "blockNumber": {
                                  "type": "string",
                                  "description": "The block number where this log was in. null when its pending. null when its pending log."
                                },
                                "transactionIndex": {
                                  "type": "string",
                                  "description": "Integer of the transactions index position log was created from. null when its pending log."
                                }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "nonce": {
                                  "type": "string",
                                  "description": "8 Bytes - hash of the generated proof-of-work. null when its pending block."
                                },
                                "hash": {
                                  "type": "string",
                                  "description": "32 Bytes - hash of the block. null when its pending block."
                                }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "from": {
                                  "type": "string",
                                  "description": "20 Bytes - address of the sender"
                                },
                                "gas": {
                                  "type": "string",
                                  "description": "gas provided by the sender"
                                },
                                "gasPrice": {
                                  "type": "string",
                                  "description": "gas price provided by the sender in Wei"
                                },
                                "input": {
                                  "type": "string",
                                  "description": "the data send along with the transaction"
                                },
                                "r": {
                                  "type": "string",
                                  "description": "ECDSA signature r"
                                },
                                "s": {
                                  "type": "string",
                                  "description": "ECDSA signature s"
                                },
                                "to": {
                                  "type": "string",
                                  "description": "20 Bytes - address of the receiver. null when it's a contract creation transaction"
                                },
                                "v": {
                                  "type": "string",
                                  "description": "ECDSA recovery id"
                                },
                                "value": {
                                  "type": "string",
                                  "description": "value transferred in Wei"
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/sendTransaction": {
      "post": {
        "operationId": "sdk-sendTransaction",
        "summary": "sendTransaction",
        "description": "Creates a new message call transaction or a contract creation for signed transactions.",
        "tags": [
          "SDK Transact Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "description": "String - The signed transaction data.",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  {
                    "type": "object",
                    "properties": null
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "import { Network, Alchemy, Wallet, Utils } from \"alchemy-sdk\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst { API_KEY, PRIVATE_KEY } = process.env;\n\nconst settings = {\n  apiKey: API_KEY,\n  network: Network.ETH_GOERLI, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\nconst wallet = new Wallet(PRIVATE_KEY);\n\nconst transaction = {\n  to: \"0xa238b6008Bc2FBd9E386A5d4784511980cE504Cd\",\n  value: Utils.parseEther(\"0.001\"),\n  gasLimit: \"21000\",\n  maxPriorityFeePerGas: Utils.parseUnits(\"5\", \"gwei\"),\n  maxFeePerGas: Utils.parseUnits(\"20\", \"gwei\"),\n  nonce: await alchemy.core.getTransactionCount(wallet.getAddress()),\n  type: 2,\n  chainId: 5, // Corresponds to ETH_GOERLI\n};\n\nconst rawTransaction = await wallet.signTransaction(transaction);\nawait alchemy.transact.sendTransaction(rawTransaction);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns the pending transaction object.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "to": {
                          "type": "string",
                          "description": "To address of transfer (hex string)."
                        },
                        "from": {
                          "type": "string",
                          "description": "From address of transfer (hex string)."
                        },
                        "nonce": {
                          "type": "number",
                          "description": "Returns the number of transactions address has ever sent"
                        },
                        "gasLimit": {
                          "type": "string",
                          "description": "The maximum gas allowed in this block."
                        },
                        "gasPrice": {
                          "type": "string",
                          "description": "Gas price provided by the sender in Wei"
                        },
                        "data": {
                          "type": "string"
                        },
                        "value": {
                          "type": "number"
                        },
                        "chainId": {
                          "type": "number"
                        },
                        "type": {
                          "type": "number"
                        },
                        "accessList": {
                          "type": "array"
                        },
                        "maxFeePerGas": {
                          "type": "number",
                          "description": "BigNumber - The maxFeePerGas to use for a transaction. This is based on the most recent block's baseFee."
                        },
                        "maxPriorityFeePerGas": {
                          "type": "number",
                          "description": "BigNumber - The maxPriorityFeePerGas to use for a transaction. This accounts for the uncle risk and for the majority of current MEV risk."
                        },
                        "customData": {
                          "type": "array"
                        },
                        "ccipReadEnabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/sendPrivateTransaction": {
      "post": {
        "summary": "sendPrivateTransaction",
        "operationId": "sdk-sendPrivateTransaction",
        "description": "Send a single private transaction through Flashbots. Private transactions are sent directly to miners and not included in the public mempool.",
        "tags": [
          "SDK Transact Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "tx"
                  ],
                  "properties": {
                    "method": {
                      "type": "string",
                      "default": "eth_sendPrivateTransaction",
                      "enum": [
                        "eth_sendPrivateTransaction"
                      ]
                    },
                    "tx": {
                      "type": "string",
                      "description": "Raw, signed transaction"
                    },
                    "maxBlockNumber": {
                      "type": "string",
                      "description": "Hex-encoded number for highest block number in which the transaction should be included."
                    },
                    "preferences": {
                      "type": "object",
                      "properties": {
                        "fast": {
                          "type": "boolean",
                          "description": "Sends transaction with fast mode when true."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "import { Network, Alchemy, Wallet, Utils } from \"alchemy-sdk\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst { API_KEY, PRIVATE_KEY } = process.env;\n\nconst settings = {\n  apiKey: API_KEY,\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\nconst wallet = new Wallet(PRIVATE_KEY);\n\nconst transaction = {\n  to: \"0xa238b6008Bc2FBd9E386A5d4784511980cE504Cd\",\n  value: Utils.parseEther(\"0.001\"),\n  gasLimit: \"21000\",\n  maxPriorityFeePerGas: Utils.parseUnits(\"5\", \"gwei\"),\n  maxFeePerGas: Utils.parseUnits(\"20\", \"gwei\"),\n  nonce: await alchemy.core.getTransactionCount(wallet.getAddress()),\n  type: 2,\n  chainId: 1, // Corresponds to ETH_MAINNET\n};\n\nconst rawTransaction = await wallet.signTransaction(transaction);\nalchemy.transact.sendPrivateTransaction(rawTransaction).then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/cancelPrivateTransaction": {
      "post": {
        "operationId": "sdk-cancelPrivateTransaction",
        "summary": "cancelPrivateTransaction",
        "description": "Request to cancel private transactions on Ethereum that are sent via eth_sendPrivateTransaction.",
        "tags": [
          "SDK Transact Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "params": {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 1,
                        "items": {
                          "type": "object",
                          "properties": {
                            "txHash": {
                              "type": "string",
                              "description": "Transaction hash for private transaction to be cancelled."
                            }
                          }
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.transact\n  .cancelPrivateTransaction(\n    \"0x2e8dff1ae477808ec0682c27fbdd250a2e628090fe4e901e644c942628113b37\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns true if transaction was successfully cancelled, false if not.",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "result": {
                          "type": "boolean"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{apiKey}/waitForTransaction": {
      "post": {
        "operationId": "sdk-waitForTransaction",
        "summary": "waitForTransaction",
        "description": "Returns a promise which will not resolve until specified transaction hash is mined. If confirmations is 0, this method is non-blocking and if the transaction has not been mined returns null. Otherwise, this method will block until the transaction has confirmed blocks mined on top of the block in which it was mined.",
        "tags": [
          "SDK Transact Endpoints"
        ],
        "parameters": [
          {
            "name": "apiKey",
            "in": "path",
            "schema": {
              "type": "string",
              "default": "docs-demo",
              "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "type": "object",
                    "properties": {
                      "transactionHash": {
                        "type": "string",
                        "description": "The hash of the transaction to wait for."
                      },
                      "confirmations": {
                        "type": "number",
                        "description": "The number of blocks to wait for."
                      },
                      "timeout": {
                        "type": "number",
                        "description": "The maximum time to wait for the transaction to confirm."
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Network, Alchemy } from \"alchemy-sdk\";\n\n// Optional config object, but defaults to demo api-key and eth-mainnet.\nconst settings = {\n  apiKey: \"demo\", // Replace with your Alchemy API Key.\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\nconst alchemy = new Alchemy(settings);\n\nalchemy.transact\n  .cancelPrivateTransaction(\n    \"0x2e8dff1ae477808ec0682c27fbdd250a2e628090fe4e901e644c942628113b37\"\n  )\n  .then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns a promise of a transaction receipt which will not resolve until specified transaction hash is mined.",
            "content": {
              "application/json": {
                "schema": {
                  "description": "A transaction receipt object, or null when no receipt was found",
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "blockHash": {
                          "type": "string",
                          "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                        },
                        "blockNumber": {
                          "type": "string",
                          "description": "The block number where this log was in. null when its pending. null when its pending log."
                        },
                        "transactionIndex": {
                          "type": "string",
                          "description": "Integer of the transactions index position log was created from. null when its pending log."
                        }
                      }
                    },
                    {
                      "type": "object",
                      "properties": {
                        "transactionHash": {
                          "type": "string",
                          "description": "32 Bytes - hash of the transaction"
                        },
                        "from": {
                          "type": "string",
                          "description": "20 Bytes - address of the sender"
                        },
                        "to": {
                          "type": "string",
                          "description": "20 Bytes - address of the receiver. null when its a contract creation transaction"
                        },
                        "cumulativeGasUsed": {
                          "type": "string",
                          "description": "The total amount of gas used when this transaction was executed in the block."
                        },
                        "gasUsed": {
                          "type": "string",
                          "description": "The amount of gas used by this specific transaction alone"
                        },
                        "contractAddress": {
                          "type": "string",
                          "description": "20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null"
                        },
                        "logs": {
                          "type": "array",
                          "description": "Array of log objects, which this transaction generated",
                          "items": {
                            "allOf": [
                              {
                                "type": "object",
                                "properties": {
                                  "blockHash": {
                                    "type": "string",
                                    "description": "32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log"
                                  },
                                  "blockNumber": {
                                    "type": "string",
                                    "description": "The block number where this log was in. null when its pending. null when its pending log."
                                  },
                                  "transactionIndex": {
                                    "type": "string",
                                    "description": "Integer of the transactions index position log was created from. null when its pending log."
                                  }
                                }
                              },
                              {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "description": "20 Bytes - address from which this log originated."
                                  },
                                  "logIndex": {
                                    "type": "string",
                                    "description": "Integer of the log index position in the block. null when its pending log."
                                  },
                                  "data": {
                                    "type": "string",
                                    "description": "Contains one or more 32 Bytes non-indexed arguments of the log."
                                  },
                                  "removed": {
                                    "type": "boolean",
                                    "description": "true when the log was removed, due to a chain reorganization. false if its a valid log."
                                  },
                                  "topics": {
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "description": "Array of zero to four 32 Bytes DATA of indexed log arguments. In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declare the event with the anonymous specifier."
                                  },
                                  "transactionHash": {
                                    "type": "string",
                                    "description": "Hash of the transactions this log was created from. null when its pending log."
                                  }
                                }
                              }
                            ]
                          }
                        },
                        "logsBloom": {
                          "type": "string",
                          "description": "256 Bytes - Bloom filter for light clients to quickly retrieve related logs"
                        },
                        "root": {
                          "type": "string",
                          "description": "32 bytes of post-transaction stateroot (pre Byzantium)"
                        },
                        "status": {
                          "type": "integer",
                          "description": "Either 1 (success) or 0 (failure)",
                          "enum": [
                            0,
                            1
                          ]
                        },
                        "effectiveGasPrice": {
                          "type": "string"
                        },
                        "type": {
                          "type": "string"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/get-all-webhooks": {
      "get": {
        "summary": "getAllWebhooks",
        "description": "This endpoint allows you to get all webhooks from every app on your team.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nalchemy.notify.getAllWebhooks().then(console.log);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns list of webhook objects.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "webhooks": {
                        "type": "array",
                        "description": "List of webhooks for your team.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "id": {
                              "type": "string",
                              "description": "Unique ID for given webhook."
                            },
                            "network": {
                              "type": "string",
                              "description": "Network of webhook",
                              "enum": [
                                "ETH_MAINNET",
                                "ETH_GOERLI",
                                "ETH_ROPSTEN",
                                "ETH_RINKEBY",
                                "ETH_KOVAN",
                                "MATIC_MAINNET",
                                "MATIC_MUMBAI",
                                "ARB_MAINNET",
                                "ARB_RINKEBY",
                                "OPT_MAINNET",
                                "OPT_KOVAN"
                              ]
                            },
                            "type": {
                              "type": "string",
                              "description": "Type of webhook.",
                              "enum": [
                                "MINED_TRANSACTION",
                                "DROPPED_TRANSACTION",
                                "ADDRESS_ACTIVITY",
                                "NFT_ACTIVITY"
                              ]
                            },
                            "url": {
                              "type": "string",
                              "description": "URL endpoint where webhook is sent"
                            },
                            "isActive": {
                              "type": "boolean",
                              "description": "(boolean) - true if webhook is active, false if not active."
                            },
                            "timeCreated": {
                              "type": "string",
                              "description": "Timestamp webhook was created."
                            },
                            "signingKey": {
                              "type": "string",
                              "description": "Signing key for given webhook."
                            },
                            "version": {
                              "type": "string",
                              "description": "Webhook version (v1 or v2)"
                            },
                            "appId": {
                              "type": "string",
                              "description": "Only exists for Mined / Dropped Transactions. The App ID of the project the webhook is connected to."
                            }
                          }
                        }
                      },
                      "totalCount": {
                        "type": "number",
                        "description": "Number of webhooks returned"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-get-all-webhooks"
      }
    },
    "/get-addresses-webhooks": {
      "get": {
        "summary": "getAddresses",
        "description": "Paginated endpoint to list all of the addresses a given Address Activity webhook is subscribed to.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          },
          {
            "name": "webhook",
            "schema": {
              "type": "string"
            },
            "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
            "in": "query",
            "required": true
          },
          {
            "name": "options",
            "in": "query",
            "schema": {
              "type": "object",
              "properties": {
                "limit": {
                  "schema": {
                    "type": "integer",
                    "default": 100
                  },
                  "description": "Number of items per page."
                },
                "pageKey": {
                  "schema": {
                    "type": "integer",
                    "default": "1"
                  },
                  "description": "Page cursor for the next page."
                }
              }
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\nconst hooks = await alchemy.notify.getAllWebhooks();\n\nconst addressesById = await alchemy.notify.getAddresses(\"wh_qv16bt12wbj9kax4\", {\n  limit: 3,\n});\nconst addressesByWebhook = await alchemy.notify.getAddresses(\n  hooks.webhooks[3],\n  { limit: 3, pageKey: 1 }\n);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "List of addresses and pagination info.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "addresses": {
                        "type": "array",
                        "description": "List of addresses associated with given webhook.",
                        "items": {
                          "type": "string"
                        }
                      },
                      "totalCount": {
                        "type": "integer",
                        "description": "Total number of addresses."
                      },
                      "pageKey": {
                        "type": "string",
                        "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response."
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-get-addresses-webhooks"
      }
    },
    "/get-nft-filters-webhooks": {
      "get": {
        "summary": "getNftFilters",
        "description": "Paginated endpoint to list all of the NFT filter objects a given webhook is subscribed to.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          },
          {
            "name": "webhook",
            "schema": {
              "type": "string"
            },
            "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
            "in": "query",
            "required": true
          },
          {
            "name": "options",
            "in": "query",
            "schema": {
              "type": "object",
              "properties": {
                "limit": {
                  "schema": {
                    "type": "integer",
                    "default": 100
                  },
                  "description": "Number of items per page."
                },
                "pageKey": {
                  "schema": {
                    "type": "integer",
                    "default": "1"
                  },
                  "description": "Page cursor for the next page."
                }
              }
            }
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\nconst hooks = await alchemy.notify.getAllWebhooks();\n\nconst nftsById = await alchemy.notify.getNftFilters(\"wh_zyhqo5im08n6ougk\", {\n  limit: 3,\n  pageKey: 1,\n});\n\nconst nftsByWebhook = await alchemy.notify.getNftFilters(hooks.webhooks[1]);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns a list of nft filter objects.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "addresses": {
                        "type": "array",
                        "description": "List of NFT filters associated with given webhook.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "contractAddress": {
                              "type": "string",
                              "description": "Contract address of the NFT in the NFT filter."
                            },
                            "tokenId": {
                              "type": "string",
                              "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                            }
                          }
                        }
                      },
                      "totalCount": {
                        "type": "integer",
                        "description": "Total number of addresses."
                      },
                      "pageKey": {
                        "type": "string",
                        "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response."
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-get-nft-filters-webhooks"
      }
    },
    "/update-webhook": {
      "put": {
        "summary": "updateWebhook",
        "description": "Allows you to update the state of an existing webhook. Input parameters is a webhook ID or object, followed by exactly one of the Update objects listed below.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "A Webhook ID, followed by one of the following objects",
                "properties": {
                  "webhook": {
                    "name": "webhook",
                    "schema": {
                      "type": "string"
                    },
                    "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
                    "in": "query",
                    "required": true
                  },
                  "WebhookStatusUpdate": {
                    "type": "object",
                    "description": "Include only one of these Update objects as the second parameter.",
                    "properties": {
                      "isActive": {
                        "type": "boolean",
                        "description": "Sets the webhook to be active or inactive."
                      }
                    }
                  },
                  "WebhookAddressUpdate": {
                    "type": "object",
                    "description": "Include only one of these Update objects as the second parameter.",
                    "properties": {
                      "addAddresses": {
                        "type": "array",
                        "description": "Array of addresses to additionally track.",
                        "items": {
                          "type": "string"
                        }
                      },
                      "removeAddresses": {
                        "type": "array",
                        "description": "Array of existing addresses to remove",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "WebhookAddressOverride": {
                    "type": "object",
                    "description": "Include only one of these Update objects as the second parameter.",
                    "properties": {
                      "newAddresses": {
                        "type": "array",
                        "description": "New addresses to track. Existing addresses will be removed.",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "WebhookNftFilterUpdate": {
                    "type": "object",
                    "description": "Include only one of these Update objects as the second parameter.",
                    "properties": {
                      "addFilters": {
                        "type": "array",
                        "description": "Array of NFT filters to additionally track.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "contractAddress": {
                              "type": "string",
                              "description": "Contract address of the NFT in the NFT filter."
                            },
                            "tokenId": {
                              "type": "string",
                              "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                            }
                          }
                        }
                      },
                      "removeFilters": {
                        "type": "array",
                        "description": "Array of existing filters to remove.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "contractAddress": {
                              "type": "string",
                              "description": "Contract address of the NFT in the NFT filter."
                            },
                            "tokenId": {
                              "type": "string",
                              "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nawait alchemy.notify.updateWebhook(\"wh_qv16bt12wbj9kax4\", { isActive: false });\n\n// Updating Address Activity Webhook: add/remove addresses\nawait alchemy.notify.updateWebhook(\"wh_qv16bt12wbj9kax4\", {\n  addAddresses: [\n    \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96010\",\n    \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96011\",\n  ],\n  removeAddresses: [\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96043\"],\n});\n\n// Updating Address Activity Webhook: replace all addresses\nawait alchemy.notify.updateWebhook(\"wh_qv16bt12wbj9kax4\", {\n  newAddresses: [\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96010\"],\n});\n\n// Updating NFT Filter Webhook: add/remove filters\nawait alchemy.notify.updateWebhook(\"wh_zyhqo5im08n6ougk\", {\n  addFilters: [\n    {\n      contractAddress: \"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n      tokenId: \"101\",\n    },\n  ],\n  removeFilters: [\n    {\n      contractAddress: \"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n      tokenId: \"24\",\n    },\n  ],\n});\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns undefined."
          }
        },
        "operationId": "sdk-update-webhook"
      }
    },
    "/create-webhook": {
      "post": {
        "summary": "createWebhook",
        "description": "This endpoint allows you to create a webhook.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "description": "URL where requests are sent"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of webhook.",
                    "enum": [
                      "MINED_TRANSACTION",
                      "DROPPED_TRANSACTION",
                      "ADDRESS_ACTIVITY",
                      "NFT_ACTIVITY"
                    ]
                  },
                  "TransactionWebhookParams": {
                    "type": "object",
                    "description": "Used for Mined / Dropped Transaction Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
                    "properties": {
                      "appId": {
                        "type": "string",
                        "description": "The app id of the project to create the mined / dropped transaction webhook on."
                      }
                    }
                  },
                  "AddressWebhookParams": {
                    "type": "object",
                    "description": "Used for Address Activity Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
                    "properties": {
                      "addresses": {
                        "type": "array",
                        "description": "Array of addresses the webhook should track activity for.",
                        "items": {
                          "type": "string"
                        }
                      },
                      "network": {
                        "type": "string",
                        "description": "Optional network to create the webhook on. If omitted, the webhook will be created on network of the app provided in the api key config.",
                        "enum": [
                          "ETH_MAINNET",
                          "ETH_GOERLI",
                          "ETH_ROPSTEN",
                          "ETH_RINKEBY",
                          "ETH_KOVAN",
                          "MATIC_MAINNET",
                          "MATIC_MUMBAI",
                          "ARB_MAINNET",
                          "ARB_RINKEBY",
                          "OPT_MAINNET",
                          "OPT_KOVAN"
                        ]
                      }
                    }
                  },
                  "NftWebhookParams": {
                    "type": "object",
                    "description": "Used for NFT Filter Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
                    "properties": {
                      "addresses": {
                        "type": "array",
                        "description": "Array of NFT filters the webhook should track.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "contractAddress": {
                              "type": "string",
                              "description": "Contract address of the NFT in the NFT filter."
                            },
                            "tokenId": {
                              "type": "string",
                              "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                            }
                          }
                        }
                      },
                      "network": {
                        "type": "string",
                        "description": "Optional network to create the webhook on. If omitted, the webhook will be created on network of the app provided in the api key config.",
                        "enum": [
                          "ETH_MAINNET",
                          "ETH_GOERLI",
                          "ETH_ROPSTEN",
                          "ETH_RINKEBY",
                          "ETH_KOVAN",
                          "MATIC_MAINNET",
                          "MATIC_MUMBAI",
                          "ARB_MAINNET",
                          "ARB_RINKEBY",
                          "OPT_MAINNET",
                          "OPT_KOVAN"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network, WebhookType } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nconst minedTxWebhook = await alchemy.notify.createWebhook(\n  \"https://webhook.site/your-webhook-url\",\n  WebhookType.MINED_TRANSACTION,\n  { appId: \"wq9fgv022aff81pg\" }\n);\n\nconst droppedTxWebhook = await alchemy.notify.createWebhook(\n  \"https://webhook.site/your-webhook-url\",\n  WebhookType.DROPPED_TRANSACTION,\n  { appId: \"wq9fgv022aff81pg\" }\n);\n\nconst addressActivityWebhook = await alchemy.notify.createWebhook(\n  \"https://webhook.site/your-webhook-url\",\n  WebhookType.ADDRESS_ACTIVITY,\n  {\n    addresses: [\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96010\"],\n    network: Network.ETH_MAINNET,\n  }\n);\n\nconst nftActivityWebhook = await alchemy.notify.createWebhook(\n  \"https://webhook.site/your-webhook-url\",\n  WebhookType.NFT_ACTIVITY,\n  {\n    filters: [\n      {\n        contractAddress: \"0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\",\n        tokenId: \"234\",\n      },\n    ],\n    network: Network.ETH_MAINNET,\n  }\n);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns webhook creation data.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "Unique ID for given webhook."
                    },
                    "network": {
                      "type": "string",
                      "description": "Network of webhook",
                      "enum": [
                        "ETH_MAINNET",
                        "ETH_GOERLI",
                        "ETH_ROPSTEN",
                        "ETH_RINKEBY",
                        "ETH_KOVAN",
                        "MATIC_MAINNET",
                        "MATIC_MUMBAI",
                        "ARB_MAINNET",
                        "ARB_RINKEBY",
                        "OPT_MAINNET",
                        "OPT_KOVAN"
                      ]
                    },
                    "type": {
                      "type": "string",
                      "description": "Type of webhook.",
                      "enum": [
                        "MINED_TRANSACTION",
                        "DROPPED_TRANSACTION",
                        "ADDRESS_ACTIVITY",
                        "NFT_ACTIVITY"
                      ]
                    },
                    "url": {
                      "type": "string",
                      "description": "URL endpoint where webhook is sent"
                    },
                    "isActive": {
                      "type": "boolean",
                      "description": "(boolean) - true if webhook is active, false if not active."
                    },
                    "timeCreated": {
                      "type": "string",
                      "description": "Timestamp webhook was created."
                    },
                    "signingKey": {
                      "type": "string",
                      "description": "Signing key for given webhook."
                    },
                    "version": {
                      "type": "string",
                      "description": "Webhook version (v1 or v2)"
                    },
                    "appId": {
                      "type": "string",
                      "description": "Only exists for Mined / Dropped Transactions. The App ID of the project the webhook is connected to."
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "sdk-create-webhook"
      }
    },
    "/delete-webhook": {
      "delete": {
        "summary": "deleteWebhook",
        "description": "Allows you to delete a webhook.",
        "tags": [
          "SDK Notify Endpoints"
        ],
        "parameters": [
          {
            "name": "X-Alchemy-Token",
            "in": "header",
            "schema": {
              "type": "string"
            },
            "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
            "example": "your-notify-auth-token"
          },
          {
            "name": "webhook",
            "schema": {
              "type": "string"
            },
            "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
            "in": "query",
            "required": true
          }
        ],
        "x-readme": {
          "explorer-enabled": false,
          "samples-languages": [
            "javascript"
          ],
          "code-samples": [
            {
              "language": "javascript",
              "name": "Alchemy SDK",
              "code": "// Setup: npm install alchemy-sdk\n// Github: https://github.com/alchemyplatform/alchemy-sdk-js\nimport { Alchemy, Network, WebhookType } from \"alchemy-sdk\";\n\n// authToken is required to use Notify APIs. Found on the top right corner of\n// https://dashboard.alchemy.com/notify.\nconst settings = {\n  authToken: \"your-notify-auth-token\",\n  network: Network.ETH_MAINNET, // Replace with your network.\n};\n\nconst alchemy = new Alchemy(settings);\n\nconst minedTxWebhook = await alchemy.notify.createWebhook(\n  \"https://webhook.site/your-webhook-url\",\n  WebhookType.MINED_TRANSACTION,\n  { appId: \"wq9fgv022aff81pg\" }\n);\n\nawait alchemy.notify.deleteWebhook(\"wh_qv16bt12wbj9kax4\");\nawait alchemy.notify.deleteWebhook(minedTxWebhook);\n"
            }
          ]
        },
        "responses": {
          "200": {
            "description": "Returns nothing."
          }
        },
        "operationId": "sdk-delete-webhook"
      }
    }
  },
  "components": {
    "schemas": {
      "apiKey": {
        "name": "apiKey",
        "in": "path",
        "schema": {
          "type": "string",
          "default": "docs-demo",
          "description": "<style>\n  .custom-style {\n    color: #048FF4;\n  }\n</style>\nFor higher throughput, <span class=\"custom-style\"><a href=\"https://alchemy.com/?a=docs-demo\" target=\"_blank\">create your own API key</a></span>\n"
        },
        "required": true
      },
      "owner": {
        "name": "owner",
        "description": "String - Address for NFT owner (can be in ENS format!).",
        "schema": {
          "type": "string"
        },
        "in": "query",
        "required": true
      },
      "wallet": {
        "name": "wallet",
        "description": "String - Wallet address to check for collection ownership.",
        "schema": {
          "type": "string"
        },
        "in": "query",
        "required": true
      },
      "pageKey": {
        "name": "pageKey",
        "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response. Pass back that pageKey as a param to fetch the next 100 NFTs.",
        "schema": {
          "type": "string"
        },
        "in": "query"
      },
      "pageSize": {
        "name": "pageSize",
        "description": "String - Number of NFTs to be returned per page. Defaults to 100. Max is 100. NOTE: Only supported on Ethereum Mainnet and Goerli, Polygon Mainnet and Mumbai, Arbitrum Mainnet and Goerli, and Optimism Mainnet and Goerli.",
        "schema": {
          "type": "integer"
        },
        "in": "query"
      },
      "contractAddresses": {
        "name": "contractAddresses[]",
        "description": "Array of contract addresses to filter the responses with. Max limit 20 contracts.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "in": "query"
      },
      "walletAddress": {
        "name": "walletAddress",
        "description": "String - Wallet address",
        "schema": {
          "type": "string",
          "default": "0xe5cB067E90D5Cd1F8052B83562Ae670bA4A211a8"
        },
        "required": true,
        "in": "query"
      },
      "omitMetadata": {
        "name": "omitMetadata",
        "description": "Boolean - if set to `false`, returns NFT metadata. Setting this to true will reduce payload size and may result in a faster API call. Defaults to `false`.",
        "schema": {
          "type": "boolean",
          "default": false
        },
        "in": "query"
      },
      "filters": {
        "name": "filters[]",
        "description": "Array of filters (as ENUMS) that will be applied to the query. NFTs that match one or more of these filters will be excluded from the response. Filter Options:\n  - SPAM: NFTs that have been classified as spam. Spam classification has a wide range of criteria that includes but is not limited to emitting fake events and copying other well-known NFTs.\n  - AIRDROPS: NFTs that have were airdropped to the user. Airdrops are defined as NFTs that were minted to a user address in a transaction sent by a different address. NOTE: this filter is currently supported on Ethereum Mainnet and Goerli only.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "SPAM",
              "AIRDROPS"
            ]
          }
        },
        "in": "query"
      },
      "contractAddress": {
        "name": "contractAddress",
        "description": "String - Contract address for the NFT collection (ERC721 and ERC1155 supported).",
        "in": "query",
        "schema": {
          "type": "string",
          "default": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"
        },
        "required": true
      },
      "tokenId": {
        "name": "tokenId",
        "description": "String - The ID of the token. Can be in hex or decimal format.",
        "in": "query",
        "schema": {
          "type": "string",
          "default": "1"
        },
        "required": true
      },
      "tokenType": {
        "name": "tokenType",
        "description": "String - 'ERC721' or 'ERC1155'; specifies type of token to query for. API requests will perform faster if this is specified.",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "startToken": {
        "name": "startToken",
        "description": "String - An offset used for pagination. Can be a hex string, or a decimal. Set to `nextToken` returned in the response to access the next page.",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "limit-nfts": {
        "name": "limit",
        "description": "Integer - Sets the total number of NFTs returned in the response. Defaults to 100.",
        "in": "query",
        "schema": {
          "type": "integer"
        }
      },
      "tokenUriTimeoutInMs": {
        "name": "tokenUriTimeoutInMs",
        "description": "No set timeout by default - When metadata is requested, this parameter is the timeout (in milliseconds) for the website hosting the metadata to respond. If you want to _only_ access the cache and not live fetch any metadata for cache misses then set this value to 0.",
        "in": "query",
        "schema": {
          "type": "integer"
        }
      },
      "withTokenBalances": {
        "name": "withTokenBalances",
        "description": "Boolean - If set to `true` the query will include the token balances per token id for each owner. `false` by default.",
        "in": "query",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "refreshCache": {
        "name": "refreshCache",
        "description": "Defaults to false for faster response times.  If true will refresh metadata for given token. If false will check the cache and use it or refresh if cache doesn't exist.",
        "in": "query",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "block": {
        "name": "block",
        "description": "String - The point in time or block number (in hex or decimal) to fetch collection ownership information for.",
        "in": "query",
        "schema": {
          "type": "string"
        },
        "required": false
      },
      "token": {
        "type": "object",
        "required": [
          "contractAddress",
          "tokenId"
        ],
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "The contract address of the NFT."
          },
          "tokenId": {
            "type": "string",
            "description": "The unique identifier of the NFT."
          },
          "tokenType": {
            "type": "string",
            "description": "The type of the NFT, such as ERC721.",
            "nullable": true
          }
        }
      },
      "tokenType_response": {
        "type": "string",
        "description": "String - 'ERC721' or 'ERC1155'"
      },
      "raw": {
        "type": "string",
        "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
      },
      "gateway": {
        "type": "string",
        "description": "String - Public gateway uri for the raw uri above."
      },
      "id": {
        "type": "object",
        "properties": {
          "tokenId": {
            "name": "tokenId",
            "description": "String - The ID of the token. Can be in hex or decimal format.",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "1"
            },
            "required": true
          },
          "tokenMetadata": {
            "type": "object",
            "properties": {
              "tokenType": {
                "type": "string",
                "description": "String - 'ERC721' or 'ERC1155'"
              }
            }
          }
        }
      },
      "tokenUri": {
        "type": "object",
        "properties": {
          "raw": {
            "type": "string",
            "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
          },
          "gateway": {
            "type": "string",
            "description": "String - Public gateway uri for the raw uri above."
          }
        }
      },
      "rawMetadata": {
        "type": "object",
        "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
        "properties": {
          "image": {
            "type": "string",
            "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
          },
          "external_url": {
            "type": "string",
            "description": "String - The image URL that appears alongside the asset image on NFT platforms."
          },
          "background_color": {
            "type": "string",
            "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
          },
          "name": {
            "type": "string",
            "description": "String - Name of the NFT asset."
          },
          "description": {
            "type": "string",
            "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
          },
          "attributes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string"
                },
                "trait_type": {
                  "type": "string"
                }
              }
            },
            "description": "Object - Traits/attributes/characteristics for each NFT asset."
          }
        }
      },
      "ownedNFT": {
        "type": "object",
        "properties": {
          "contract": {
            "description": "Object - Contract for returned NFT",
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "description": "String - Address of NFT contract."
              }
            }
          },
          "id": {
            "type": "object",
            "properties": {
              "tokenId": {
                "name": "tokenId",
                "description": "String - The ID of the token. Can be in hex or decimal format.",
                "in": "query",
                "schema": {
                  "type": "string",
                  "default": "1"
                },
                "required": true
              },
              "tokenMetadata": {
                "type": "object",
                "properties": {
                  "tokenType": {
                    "type": "string",
                    "description": "String - 'ERC721' or 'ERC1155'"
                  }
                }
              }
            }
          },
          "balance": {
            "type": "string",
            "description": "String - Token balance"
          },
          "title": {
            "type": "string",
            "description": "String - Name of the NFT asset."
          },
          "description": {
            "type": "string",
            "description": "String - Brief human-readable description"
          },
          "tokenUri": {
            "type": "object",
            "properties": {
              "raw": {
                "type": "string",
                "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
              },
              "gateway": {
                "type": "string",
                "description": "String - Public gateway uri for the raw uri above."
              }
            }
          },
          "media": {
            "type": "object",
            "properties": {
              "raw": {
                "type": "string",
                "description": "String - Uri representing the location of the NFT's original metadata blob. This is a backup for you to parse when the metadata field is not automatically populated."
              },
              "gateway": {
                "type": "string",
                "description": "String - Public gateway uri for the raw uri above."
              },
              "thumbnail": {
                "type": "string",
                "description": "URL for a resized thumbnail of the NFT media asset."
              },
              "format": {
                "type": "string",
                "description": "The media format (jpg, gif, png, etc.) of the gateway and thumbnail assets."
              },
              "bytes": {
                "type": "integer",
                "description": "The size of the media asset in bytes."
              }
            }
          },
          "rawMetadata": {
            "type": "object",
            "description": "String - Relevant metadata for NFT contract. This is useful for viewing image url, traits, etc. without having to follow the metadata url in tokenUri to parse manually.",
            "properties": {
              "image": {
                "type": "string",
                "description": "String - URL to the NFT asset image. Can be standard URLs pointing to images on conventional servers, IPFS, or Arweave. Most types of images (SVGs, PNGs, JPEGs, etc.) are supported by NFT marketplaces."
              },
              "external_url": {
                "type": "string",
                "description": "String - The image URL that appears alongside the asset image on NFT platforms."
              },
              "background_color": {
                "type": "string",
                "description": "String - Background color of the NFT item. Usually must be defined as a six-character hexadecimal."
              },
              "name": {
                "type": "string",
                "description": "String - Name of the NFT asset."
              },
              "description": {
                "type": "string",
                "description": "String - Human-readable description of the NFT asset. (Markdown is supported/rendered on OpenSea and other NFT platforms)"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "value": {
                      "type": "string"
                    },
                    "trait_type": {
                      "type": "string"
                    }
                  }
                },
                "description": "Object - Traits/attributes/characteristics for each NFT asset."
              }
            }
          },
          "timeLastUpdated": {
            "type": "string",
            "description": "String - ISO timestamp of the last cache refresh for the information returned in the metadata field."
          },
          "error": {
            "type": "string",
            "description": "String - A string describing a particular reason that we were unable to fetch complete metadata for the NFT."
          }
        }
      },
      "owners": {
        "type": "object",
        "properties": {
          "ownerAddresses": {
            "description": "List of all addresses that own one of the NFTs from the queried contract address.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "X-Alchemy-Token": {
        "name": "X-Alchemy-Token",
        "in": "header",
        "schema": {
          "type": "string"
        },
        "description": "Auth Token found on the top right corner of https://dashboard.alchemy.com/notify. Required to use Notify APIs.",
        "example": "your-notify-auth-token"
      },
      "webhook_id": {
        "name": "webhook",
        "schema": {
          "type": "string"
        },
        "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
        "in": "query",
        "required": true
      },
      "getWebhookListOptions": {
        "name": "options",
        "in": "query",
        "schema": {
          "type": "object",
          "properties": {
            "limit": {
              "schema": {
                "type": "integer",
                "default": 100
              },
              "description": "Number of items per page."
            },
            "pageKey": {
              "schema": {
                "type": "integer",
                "default": "1"
              },
              "description": "Page cursor for the next page."
            }
          }
        }
      },
      "limit": {
        "name": "limit",
        "schema": {
          "type": "integer",
          "default": 100
        },
        "description": "Number of items per page.",
        "in": "query"
      },
      "after": {
        "name": "after",
        "schema": {
          "type": "string",
          "default": "1"
        },
        "description": "Page cursor for the next page.",
        "in": "query"
      },
      "create_webhook": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL where requests are sent"
          },
          "type": {
            "type": "string",
            "description": "Type of webhook.",
            "enum": [
              "MINED_TRANSACTION",
              "DROPPED_TRANSACTION",
              "ADDRESS_ACTIVITY",
              "NFT_ACTIVITY"
            ]
          },
          "TransactionWebhookParams": {
            "type": "object",
            "description": "Used for Mined / Dropped Transaction Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
            "properties": {
              "appId": {
                "type": "string",
                "description": "The app id of the project to create the mined / dropped transaction webhook on."
              }
            }
          },
          "AddressWebhookParams": {
            "type": "object",
            "description": "Used for Address Activity Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
            "properties": {
              "addresses": {
                "type": "array",
                "description": "Array of addresses the webhook should track activity for.",
                "items": {
                  "type": "string"
                }
              },
              "network": {
                "type": "string",
                "description": "Optional network to create the webhook on. If omitted, the webhook will be created on network of the app provided in the api key config.",
                "enum": [
                  "ETH_MAINNET",
                  "ETH_GOERLI",
                  "ETH_ROPSTEN",
                  "ETH_RINKEBY",
                  "ETH_KOVAN",
                  "MATIC_MAINNET",
                  "MATIC_MUMBAI",
                  "ARB_MAINNET",
                  "ARB_RINKEBY",
                  "OPT_MAINNET",
                  "OPT_KOVAN"
                ]
              }
            }
          },
          "NftWebhookParams": {
            "type": "object",
            "description": "Used for NFT Filter Webhooks. \nInclude only one of these Params objects as the third parameter.\n",
            "properties": {
              "addresses": {
                "type": "array",
                "description": "Array of NFT filters the webhook should track.",
                "items": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Contract address of the NFT in the NFT filter."
                    },
                    "tokenId": {
                      "type": "string",
                      "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                    }
                  }
                }
              },
              "network": {
                "type": "string",
                "description": "Optional network to create the webhook on. If omitted, the webhook will be created on network of the app provided in the api key config.",
                "enum": [
                  "ETH_MAINNET",
                  "ETH_GOERLI",
                  "ETH_ROPSTEN",
                  "ETH_RINKEBY",
                  "ETH_KOVAN",
                  "MATIC_MAINNET",
                  "MATIC_MUMBAI",
                  "ARB_MAINNET",
                  "ARB_RINKEBY",
                  "OPT_MAINNET",
                  "OPT_KOVAN"
                ]
              }
            }
          }
        }
      },
      "update_webhook_addresses": {
        "type": "object",
        "required": [
          "webhook_id"
        ],
        "properties": {
          "webhook_id": {
            "type": "string",
            "description": "ID of the address activity webhook"
          },
          "addresses_to_add": {
            "type": "array",
            "description": "List of addresses to add, use [] if none.",
            "items": {
              "type": "string"
            }
          },
          "addresses_to_remove": {
            "type": "array",
            "description": "List of addresses to remove, use [] if none.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "update_webhook_nft_filters": {
        "type": "object",
        "required": [
          "webhook_id"
        ],
        "properties": {
          "webhook_id": {
            "type": "string",
            "description": "ID of the address activity webhook"
          },
          "nft_filters_to_add": {
            "type": "array",
            "description": "List of nft filters to add, use [] if none.",
            "items": {
              "type": "object",
              "properties": {
                "contractAddress": {
                  "type": "string",
                  "description": "Contract address of the NFT in the NFT filter."
                },
                "tokenId": {
                  "type": "string",
                  "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                }
              }
            }
          },
          "nft_filters_to_remove": {
            "type": "array",
            "description": "List of addresses to remove, use [] if none.",
            "items": {
              "type": "object",
              "properties": {
                "contractAddress": {
                  "type": "string",
                  "description": "Contract address of the NFT in the NFT filter."
                },
                "tokenId": {
                  "type": "string",
                  "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                }
              }
            }
          }
        }
      },
      "replace_webhook_addresses": {
        "type": "object",
        "properties": {
          "webhook_id": {
            "type": "string",
            "description": "ID of the address activity webhook."
          },
          "addresses": {
            "type": "array",
            "description": "New list of addresses to track. This replaces any existing addresses.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "update_webhook_endpoint": {
        "type": "object",
        "description": "A Webhook ID, followed by one of the following objects",
        "properties": {
          "webhook": {
            "name": "webhook",
            "schema": {
              "type": "string"
            },
            "description": "One of the following:\n  1. String - Webhook ID associated with the webhook\n  2. Webhook - Javascript object representing the webhook returned in getAllWebhooks()\n",
            "in": "query",
            "required": true
          },
          "WebhookStatusUpdate": {
            "type": "object",
            "description": "Include only one of these Update objects as the second parameter.",
            "properties": {
              "isActive": {
                "type": "boolean",
                "description": "Sets the webhook to be active or inactive."
              }
            }
          },
          "WebhookAddressUpdate": {
            "type": "object",
            "description": "Include only one of these Update objects as the second parameter.",
            "properties": {
              "addAddresses": {
                "type": "array",
                "description": "Array of addresses to additionally track.",
                "items": {
                  "type": "string"
                }
              },
              "removeAddresses": {
                "type": "array",
                "description": "Array of existing addresses to remove",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "WebhookAddressOverride": {
            "type": "object",
            "description": "Include only one of these Update objects as the second parameter.",
            "properties": {
              "newAddresses": {
                "type": "array",
                "description": "New addresses to track. Existing addresses will be removed.",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "WebhookNftFilterUpdate": {
            "type": "object",
            "description": "Include only one of these Update objects as the second parameter.",
            "properties": {
              "addFilters": {
                "type": "array",
                "description": "Array of NFT filters to additionally track.",
                "items": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Contract address of the NFT in the NFT filter."
                    },
                    "tokenId": {
                      "type": "string",
                      "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                    }
                  }
                }
              },
              "removeFilters": {
                "type": "array",
                "description": "Array of existing filters to remove.",
                "items": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Contract address of the NFT in the NFT filter."
                    },
                    "tokenId": {
                      "type": "string",
                      "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                    }
                  }
                }
              }
            }
          }
        }
      },
      "webhook_object_response": {
        "type": "object",
        "properties": {
          "webhooks": {
            "type": "array",
            "description": "List of webhooks for your team.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Unique ID for given webhook."
                },
                "network": {
                  "type": "string",
                  "description": "Network of webhook",
                  "enum": [
                    "ETH_MAINNET",
                    "ETH_GOERLI",
                    "ETH_ROPSTEN",
                    "ETH_RINKEBY",
                    "ETH_KOVAN",
                    "MATIC_MAINNET",
                    "MATIC_MUMBAI",
                    "ARB_MAINNET",
                    "ARB_RINKEBY",
                    "OPT_MAINNET",
                    "OPT_KOVAN"
                  ]
                },
                "type": {
                  "type": "string",
                  "description": "Type of webhook.",
                  "enum": [
                    "MINED_TRANSACTION",
                    "DROPPED_TRANSACTION",
                    "ADDRESS_ACTIVITY",
                    "NFT_ACTIVITY"
                  ]
                },
                "url": {
                  "type": "string",
                  "description": "URL endpoint where webhook is sent"
                },
                "isActive": {
                  "type": "boolean",
                  "description": "(boolean) - true if webhook is active, false if not active."
                },
                "timeCreated": {
                  "type": "string",
                  "description": "Timestamp webhook was created."
                },
                "signingKey": {
                  "type": "string",
                  "description": "Signing key for given webhook."
                },
                "version": {
                  "type": "string",
                  "description": "Webhook version (v1 or v2)"
                },
                "appId": {
                  "type": "string",
                  "description": "Only exists for Mined / Dropped Transactions. The App ID of the project the webhook is connected to."
                }
              }
            }
          },
          "totalCount": {
            "type": "number",
            "description": "Number of webhooks returned"
          }
        }
      },
      "return_webhook_data": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique ID for given webhook."
          },
          "network": {
            "type": "string",
            "description": "Network of webhook",
            "enum": [
              "ETH_MAINNET",
              "ETH_GOERLI",
              "ETH_ROPSTEN",
              "ETH_RINKEBY",
              "ETH_KOVAN",
              "MATIC_MAINNET",
              "MATIC_MUMBAI",
              "ARB_MAINNET",
              "ARB_RINKEBY",
              "OPT_MAINNET",
              "OPT_KOVAN"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of webhook.",
            "enum": [
              "MINED_TRANSACTION",
              "DROPPED_TRANSACTION",
              "ADDRESS_ACTIVITY",
              "NFT_ACTIVITY"
            ]
          },
          "url": {
            "type": "string",
            "description": "URL endpoint where webhook is sent"
          },
          "isActive": {
            "type": "boolean",
            "description": "(boolean) - true if webhook is active, false if not active."
          },
          "timeCreated": {
            "type": "string",
            "description": "Timestamp webhook was created."
          },
          "signingKey": {
            "type": "string",
            "description": "Signing key for given webhook."
          },
          "version": {
            "type": "string",
            "description": "Webhook version (v1 or v2)"
          },
          "appId": {
            "type": "string",
            "description": "Only exists for Mined / Dropped Transactions. The App ID of the project the webhook is connected to."
          }
        }
      },
      "gas_price_low": {
        "type": "integer",
        "description": "Low end of gas price threshold, null if not gas price webhook."
      },
      "gas_price_high": {
        "type": "integer",
        "description": "High end of gas price threshold, null if not gas price webhook."
      },
      "gas_price_type": {
        "type": "integer",
        "description": "Metric used for gas price threshold, null if not gas price webhook"
      },
      "version": {
        "type": "string",
        "description": "V1 or V2",
        "enum": [
          "V1",
          "V2"
        ]
      },
      "webhook_addresses_response": {
        "type": "object",
        "properties": {
          "addresses": {
            "type": "array",
            "description": "List of addresses associated with given webhook.",
            "items": {
              "type": "string"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of addresses."
          },
          "pageKey": {
            "type": "string",
            "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response."
          }
        }
      },
      "create_webhook_response": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique ID for given webhook."
          },
          "network": {
            "type": "string",
            "description": "Network of webhook",
            "enum": [
              "ETH_MAINNET",
              "ETH_GOERLI",
              "ETH_ROPSTEN",
              "ETH_RINKEBY",
              "ETH_KOVAN",
              "MATIC_MAINNET",
              "MATIC_MUMBAI",
              "ARB_MAINNET",
              "ARB_RINKEBY",
              "OPT_MAINNET",
              "OPT_KOVAN"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of webhook.",
            "enum": [
              "MINED_TRANSACTION",
              "DROPPED_TRANSACTION",
              "ADDRESS_ACTIVITY",
              "NFT_ACTIVITY"
            ]
          },
          "url": {
            "type": "string",
            "description": "URL endpoint where webhook is sent"
          },
          "isActive": {
            "type": "boolean",
            "description": "(boolean) - true if webhook is active, false if not active."
          },
          "timeCreated": {
            "type": "string",
            "description": "Timestamp webhook was created."
          },
          "signingKey": {
            "type": "string",
            "description": "Signing key for given webhook."
          },
          "version": {
            "type": "string",
            "description": "Webhook version (v1 or v2)"
          },
          "appId": {
            "type": "string",
            "description": "Only exists for Mined / Dropped Transactions. The App ID of the project the webhook is connected to."
          }
        }
      },
      "nft_filter": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "Contract address of the NFT in the NFT filter."
          },
          "tokenId": {
            "type": "string",
            "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
          }
        }
      },
      "webhook_nft_filters_response": {
        "type": "object",
        "properties": {
          "addresses": {
            "type": "array",
            "description": "List of NFT filters associated with given webhook.",
            "items": {
              "type": "object",
              "properties": {
                "contractAddress": {
                  "type": "string",
                  "description": "Contract address of the NFT in the NFT filter."
                },
                "tokenId": {
                  "type": "string",
                  "description": "Token ID of the NFT in the NFT Filter. 0x-prefixed hexidecimal or decimal string."
                }
              }
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of addresses."
          },
          "pageKey": {
            "type": "string",
            "description": "String - Cursor key for pagination. If more results are available, a pageKey will be returned in the response."
          }
        }
      },
      "network": {
        "type": "string",
        "description": "Network of webhook",
        "enum": [
          "ETH_MAINNET",
          "ETH_GOERLI",
          "ETH_ROPSTEN",
          "ETH_RINKEBY",
          "ETH_KOVAN",
          "MATIC_MAINNET",
          "MATIC_MUMBAI",
          "ARB_MAINNET",
          "ARB_RINKEBY",
          "OPT_MAINNET",
          "OPT_KOVAN"
        ]
      },
      "webhook_type": {
        "type": "string",
        "description": "Type of webhook.",
        "enum": [
          "MINED_TRANSACTION",
          "DROPPED_TRANSACTION",
          "ADDRESS_ACTIVITY",
          "NFT_ACTIVITY"
        ]
      },
      "get_nft_metadata_batch_response": {
        "type": "object",
        "required": [
          "contract",
          "tokenId",
          "tokenType",
          "title",
          "description",
          "timeLastUpdated"
        ],
        "properties": {
          "contract": {
            "type": "object",
            "required": [
              "address",
              "name",
              "symbol",
              "totalSupply",
              "tokenType"
            ],
            "properties": {
              "address": {
                "type": "string",
                "description": "The contract address of the NFT."
              },
              "name": {
                "type": "string",
                "description": "The name of the NFT contract."
              },
              "symbol": {
                "type": "string",
                "description": "The symbol of the NFT contract."
              },
              "totalSupply": {
                "type": "string",
                "description": "The total supply of the NFT contract."
              },
              "tokenType": {
                "type": "string",
                "description": "The type of the NFT contract, such as ERC721."
              }
            }
          },
          "tokenId": {
            "type": "string",
            "description": "The unique identifier of the NFT."
          },
          "tokenType": {
            "type": "string",
            "description": "The type of the NFT, such as ERC721."
          },
          "title": {
            "type": "string",
            "description": "The title of the NFT.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the NFT.",
            "nullable": true
          },
          "timeLastUpdated": {
            "type": "string",
            "format": "date-time",
            "description": "The time when the metadata was last updated."
          },
          "metadataError": {
            "type": "string",
            "description": "An error message if there was a problem fetching the metadata.",
            "nullable": true
          },
          "rawMetadata": {
            "type": "object",
            "description": "The raw metadata of the NFT.",
            "nullable": true,
            "properties": {
              "image": {
                "type": "string",
                "description": "The IPFS hash of the image associated with the NFT."
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": [
                    "key",
                    "value"
                  ],
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "The key of the attribute."
                    },
                    "value": {
                      "type": "string",
                      "description": "The value of the attribute."
                    }
                  }
                }
              }
            }
          },
          "tokenUri": {
            "type": "object",
            "description": "The URI of the NFT.",
            "nullable": true,
            "properties": {
              "raw": {
                "type": "string",
                "description": "The raw URI of the NFT."
              },
              "gateway": {
                "type": "string",
                "description": "The URI of the NFT accessed through a gateway."
              }
            }
          },
          "media": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "The URL of the media.",
                  "nullable": true
                }
              }
            }
          },
          "spamInfo": {
            "type": "object",
            "description": "Information about whether the NFT has been flagged as spam.",
            "nullable": true
          }
        }
      },
      "nftSale": {
        "type": "object",
        "properties": {
          "marketplace": {
            "type": "string",
            "description": "The on-chain marketplace where the sale took place."
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address of the NFT."
          },
          "tokenId": {
            "type": "string",
            "description": "The token id of the NFT."
          },
          "quantity": {
            "type": "string",
            "description": "The quantity of NFTs sold in the sale."
          },
          "buyerAddress": {
            "type": "string",
            "description": "The address of the NFT buyer."
          },
          "sellerAddress": {
            "type": "string",
            "description": "The address of the NFT seller."
          },
          "taker": {
            "type": "string",
            "description": "Whether the buyer or seller was the taker in the sale.",
            "enum": [
              "buyer",
              "seller"
            ]
          },
          "sellerFee": {
            "type": "object",
            "description": "The fee paid by the seller in the sale.",
            "properties": {
              "amount": {
                "type": "string",
                "description": "The amount of the fee."
              },
              "currency": {
                "type": "string",
                "description": "The currency of the fee.",
                "enum": [
                  "eth"
                ]
              }
            }
          },
          "marketplaceFee": {
            "type": "object",
            "description": "The fee paid to the marketplace in the sale, if applicable.",
            "properties": {
              "amount": {
                "type": "string",
                "description": "The amount of the fee."
              },
              "currency": {
                "type": "string",
                "description": "The currency of the fee.",
                "enum": [
                  "eth"
                ]
              }
            }
          },
          "royaltyFee": {
            "type": "object",
            "description": "The royalty fee paid in the sale, if applicable.",
            "properties": {
              "amount": {
                "type": "string",
                "description": "The amount of the fee."
              },
              "currency": {
                "type": "string",
                "description": "The currency of the fee.",
                "enum": [
                  "eth"
                ]
              }
            }
          },
          "blockNumber": {
            "type": "integer",
            "description": "The block number where the sale took place."
          },
          "logIndex": {
            "type": "integer",
            "description": "The log index of the sale in the block."
          },
          "bundleIndex": {
            "type": "integer",
            "description": "The bundle index of the sale."
          },
          "transactionHash": {
            "type": "string",
            "description": "The transaction hash of the sale."
          }
        }
      },
      "matchedNftContractInfo": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Address of the NFT contract."
          },
          "name": {
            "type": "string",
            "description": "Name of the NFT contract."
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the NFT contract."
          },
          "totalSupply": {
            "type": "string",
            "description": "Total supply of NFTs for the contract."
          },
          "tokenType": {
            "type": "string",
            "description": "Type of the NFT contract, either \"ERC721\" or \"ERC1155\"."
          },
          "openSea": {
            "type": "object",
            "description": "OpenSea metadata for the NFT contract.",
            "properties": {
              "floorPrice": {
                "type": "number",
                "description": "Minimum price for an NFT to be sold on OpenSea."
              },
              "collectionName": {
                "type": "string",
                "description": "Name of the collection on OpenSea."
              },
              "safelistRequestStatus": {
                "type": "string",
                "description": "Current status of the contract's safelist request on OpenSea."
              },
              "imageUrl": {
                "type": "string",
                "description": "URL of the main image for the NFT contract."
              },
              "description": {
                "type": "string",
                "description": "Description of the NFT contract."
              },
              "externalUrl": {
                "type": "string",
                "description": "External URL of the NFT contract."
              },
              "twitterUsername": {
                "type": "string",
                "description": "Twitter username for the NFT contract."
              },
              "discordUrl": {
                "type": "string",
                "description": "URL for the NFT contract's Discord server."
              },
              "lastIngestedAt": {
                "type": "string",
                "description": "Timestamp of the last time the contract's metadata was updated on OpenSea."
              }
            }
          }
        }
      }
    }
  }
}